// SMatrix example of usage/**  \page SMatrixDoc SMatrix Class Properties  The template ROOT::Math::SMatrix class has 4 template parameters which define, at compile time, its properties. These are:  <ul> <li> type of the contained elements, T, for example <em>float</em> or <em>double</em>;</li> <li>number of rows;</li> <li> number of columns;</li> <li>representation type (\ref MatRep). This is a class describing the underlined storage model of the Matrix. Presently exists only two types of this class:    <ol> <li>ROOT::Math::MatRepStd for a general nrows x ncols matrix. This class is itself a template on the contained type T, the number of rows and the number of columns. Its data member is an array T[nrows*ncols] containing the matrix data. The data are stored in the row-major C convention.  For example, for a matrix, M, of size 3x3, the data \f$ \left[a_0,a_1,a_2,.......,a_7,a_8 \right] \f$d are stored in the following order:          \f[         M = \left( \begin{array}{ccc}          a_0 & a_1 & a_2  \\          a_3 & a_4  & a_5  \\ 		 a_6 & a_7  & a_8   \end{array} \right)      \f] </li> <li>ROOT::Math::MatRepSym for a symmetric matrix of size NxN. This class is a template on the contained type and on the symmetric matrix size, N.  It has as data member an array of type T of size N*(N+1)/2, containing the lower diagonal block of the matrix.  The order follows the lower diagonal block, still in a row-major convention.   For example for a symmetric 3x3 matrix the order of the 6 elements \f$ \left[a_0,a_1.....a_5 \right]\f$ is:       \f[       M = \left( \begin{array}{ccc}        a_0 & a_1  & a_3  \\        a_1 & a_2  & a_4  \\       a_3 & a_4 & a_5   \end{array} \right)       \f]  </li>  </ol> </li> </ul><h3>Creating a matrix</h3>The following constructors are available to create a matrix: <ul><li>Default constructor for a zero matrix (all elements equal to zero).</li><li>Constructor of an identity matrix.</li><li>Copy constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix. </li><li>Constructor (and assignment) from a matrix expression, like D = A*B + C. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like A = A*B + C, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation. </li><li>Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the <em>begin</em> and <em>end</em> of the iterator or the <em>begin</em> and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing the lower (default case) or the upper diagonal part.</li></ul> <p>Here are some examples on how to create a matrix. We use <em>typedef's</em> in the following examples to avoid the full C++ names for the matrix classes. Notice that for a general matrix the representation has the default value, ROOT::Math::MatRepStd, and it is not needed to be specified. Furtheremore, for a general square matrix, the number of column may be as well omitted.</p><pre><em>// typedef definitions used in the following declarations</em> typedef ROOT::Math::SMatrix&lt;double,3&gt;                                       SMatrix33;      typedef ROOT::Math::SMatrix&lt;double,2&gt;                                       SMatrix22;typedef ROOT::Math::SMatrix&lt;double,3,3,ROOT::Math::MatRepSym&lt;double,3&gt; &gt;    SMatrixSym3;typedef ROOT::Math::SVector&gt;double,2&gt;                                       SVector2; typedef ROOT::Math::SVector&gt;double,3&gt;                                       SVector3;typedef ROOT::Math::SVector&gt;double,6&gt;                                       SVector6; SMatrix33   m0;                         <em>// create a zero 3x3 matrix</em><em>// create an 3x3 identity matrix </em>SMatrix33   i = ROOT::Math::SMatrixIdentity();      double   a[9] = {1,2,3,4,5,6,7,8,9};    <em>// input matrix data</em>SMatrix33   m(a,9);                     <em>// create a matrix using the a[] data</em><em>// this will produce the 3x3 matrix//    (  1    2    3 //       4    5    6//       7    8    9  )</em></pre>Example to fill a symmetric matrix from an <em>std::vector</em>: <pre>std::vector&lt;double&gt; v(6);         for (int i = 0; i<6; ++i) v[i] = double(i);SMatrixSym3  s(v.begin(),v.end())                   // this will produce the symmetric  matrix//    (  1    4    5 //       4    2    6//       5    6    3  )<em>// create a a general matrix from a symmetric matrix. The opposite will not compile</em>SMatrix33    m2 = s;                   </pre><h3>Accessing and Setting Methods</h3>The matrix elements can be set using the <em>operator()(irow,icol)</em>, where irow and icol are the row and column indexes or by using the iterator interface. Notice that the indexes start from zero and not from one as in Fortran.  <br>The elements can be accessed by these same methods and also by using the ROOT::Math::SMatrix::apply function. The <em>apply(i)</em> function has exactly the same behavior for general and symmetric matrices, in contrast to the iterator access methods which behave differently (it follows the data order). <pre>SMatrix33   m; m(0,0)  = 1;                          <em> // set the element in first row and first column</em>     *(m.<strong>begin</strong>()+1) = 2;                    <em>// set the second element (0,1)</em>double x = m(2,1);                     <em>// return the element in third row and first column</em>x = m.<strong>apply</strong>(7);                        <em>// return the 8-th element (row=2,col=1) </em>x = *(m.<strong>begin</strong>()+7);                    <em>// return the 8-th element (row=2,col=1)</em><em>// symmetric matrices (note the difference in behavior between apply and the iterators)</em>x = *(m.<strong>begin</strong>()+4)                     <em>// return the element (row=2,col=1). </em>x = m.<strong>apply</strong>(7);                        <em>// returns again the (row=2,col=1) element</em>                                        </pre>There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns in (from) a matrix. In addition one can put (get) a sub-matrix as another ROOT::Math::SMatrix object in a matrix. If the size of the the sub-vector or sub-matrix are larger than the matrix size a static assert ( a compilation error) is produced. The non-const methods are: <pre> SMatrix33            m;SVector2       v2(1,2);<em>// place a vector of size 2 in the first row starting from element (0,1) : m(0,1) = v2[0]</em>m.<strong>Place_in_row</strong>(v2,0,1); <em>// place the vector in the second column from (0,1) : m(0,1) = v2[0]   </em>             m.<strong>Place in_col</strong>(v2,0,1);                SMatrix22           m2;<em>// place the sub-matrix m2 in m starting from the element (1,1) : m(1,1) = m2(0,0)  </em> m.<strong>Place_at</strong>(m2,1,1);                    SVector3     v3(1,2,3);<em>// set v3 as the diagonal elements of m  : m(i,i) = v3[i] for i=0,1,2</em>m.<strong>SetDiagonal</strong>(v3)                    </pre>The const methods retrieving contents (getting slices of a matrix) are: <pre>a = {1,2,3,4,5,6,7,8,9}; SMatrix33       m(a,a+9); SVector3 irow = m.<strong>Row</strong>(0);             <em>// return as vector the first matrix row  </em>SVector3 jcol = m.<strong>Col</strong>(1);            <em>// return as vector the second matrix column  </em><em>// return a slice of the first row from element (0,1) : r2[0] = m(0,1); r2[1] = m(0,2)</em>SVector2 r2   =  m.<strong>SubRow</strong>&lt;SVector2&gt; (0,1);    <em>// return a slice of the second column from element (0,1) : c2[0] = m(0,1); c2[1] = m(1,1);</em>SVector2 c2   =  m.<strong>SubCol</strong>&lt;SVector2&gt; (1,0);   <em>// return a sub-matrix 2x2 with the upper left corner at the values (1,1)</em>SMatrix22 subM = m.<strong>Sub</strong>&lt;SMatrix22&gt;   (1,1); <em>// return the diagonal element in a SVector</em>SVector3  diag = m.<strong>Diagonal</strong>(); <em>// return the upper(lower) block of the matrix m</em>SVector6 vub = m.<strong>UpperBlock</strong>();        <em>//  vub = [ 1, 2, 3, 5, 6, 9 ]</em>SVector6 vlb = m.<strong>LowerBlock</strong>();       <em> //  vlb = [ 1, 4, 5, 7, 8, 9 ] </em></pre><h3>Matrix Operators </h3><p>The matrix defines the following operators described below. The<em> m1,m2,m3</em> are matrices of the same type and <em>a</em> is a scalar value: </p><pre>m1 == m2           <em>// returns whether m1 is equal to m2 (element by element comparison) </em> m1 != m2           <em>// returns whether m1 is NOT equal to m2 (element by element comparison) </em> m1 &lt; m2            <em>// returns whether m1 is less than m2 (element wise comparison)</em>m1 &gt; m2            <em>// returns whether m1 is greater than m2 (element wise comparison)</em><em>// in the following m1 and m3 can be general and m2 symmetric, but not vice-versa</em>m1 += m2           <em>// add m2 to m1</em>m1 -= m2           <em>// subtract m2 to m1 </em>m3 = m1 + m2       <em>// matrix addition </em>m1 - m2            <em>// matrix subtraction</em><em>// Multiplication and division via a scalar value a</em> m3 = a*m1; m3 = m1*a; m3 = m1/a;  </pre><strong>Matrix - Vector multiplication</strong>: it compiles only if m1 is a N1 x N2 matrix and v2 is a N2 size vector and v3, the returned vector, is of size N1. <pre>v3 = m1 * v2   <em>// \f$ v3_i = \sum_{j} m1_{ij} v2_j  \f$</em></pre><strong>Matrix - Matrix  multiplication: </strong>it compiles only if  m1 is a  N1 x N2 matrix , m2 is a N2 x N3 matrix and m3 is a N1 x N3 matrix. In the case that m1 and m2 are symmetric matrices, m3 is a general one, since their product is not guaranteed to be symmetric.   <pre>m3 = m1 * m2    <em>// \f$ m3_{ij} = \sum_{k} m1_{ik} m2_{kj}  \f$</em></pre><h3>Matrix Functions</h3>The most used matrix functions are: <ul><li><strong>ROOT::Math::Transpose</strong>(M) : return the transpose matrix, \f$ M^T \f$</li><li><strong>ROOT::Math::Similarity</strong>( v, M) : returns the scalar value resulting from the matrix- vector product \f$ v^T M v \f$ </li><li><strong>ROOT::Math::Similarity</strong>( U, M) : returns the matrix resulting from the product \f$ U  M U^T \f$. If M is symmetric, the returned resulting matrix  is also symmetric</li><li><strong>ROOT::Math::SimilarityT</strong>( U, M) : returns the matrix resulting from the product \f$ U^T  M U \f$. If M is symmetric, the returned resulting matrix  is also symmetric</li></ul>See \ref MatrixFunctions for the documentation of all existing one in the package. <h3>Linear Algebra Functions</h3> Only limited linear algebra functionality is available for SMatrix. It is possible for squared matrices NxN,  to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than 6x6 or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large (N > 6)  symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large (N > 6) general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine <a href="http://wwwasdoc.web.cern.ch/wwwasdoc/shortwrupsdir/f010/top.html">dinv</a>.   <pre><em>//  Invert a NxN matrix. The inverted matrix replace the existing one and returns if the result is successful</em>bool ret = m.<strong>Invert</strong>()  <em>// return the inverse matrix of m. If the inversion fails ifail is different than zero</em>     int ifail = 0;mInv = m.<strong>Inverse</strong>(ifail);  </pre> The determinant of a square matrix can be obtained as follows: <pre>double det; <em>// calculate the determinant modyfing the matrix content. Returns if the calculation was successful</em>bool ret = m.<strong>Det</strong>(det);    <em>// calculate the determinant using a temporary matrix but preserving the matrix content </em>bool ret = n.<strong>Det2</strong>(det);</pre><br>*/