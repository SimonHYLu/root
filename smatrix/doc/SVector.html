// SVector example of usage/**  \page SVectorDoc SVector Class Properties   The template ROOT::Math::SVector class has 2 template parameters which define, at compile time, its properties. These are:  <ul> <li> type of the contained elements, for example <em>float</em> or double. </li> <li>size of the vector.</li> </ul><h3>Creating a Vector </h3>The following constructors are available to create a vector: <ul><li>Default constructor for a zero vector (all elements equal to zero)</li><li>Constructor (and assignment) from a vector expression, like v = p*q + w. Due to the expression template technique, no temporary objects are created in this operation. </li><li>Construct a vector passing directly the elements. This is possible only for vector up to size 10.  <li>Constructor from an iterator copying the data refered by the iterator. It is possible to specify the <em>begin</em> and <em>end</em> of the iterator or the <em>begin</em> and the size.Note that for the Vector the iterator is not generic and must be of type <em>T*,</em> where T is the type of the contained elements. </li></ul> <p>Here are some examples on how to create a vector. In the following we assume that we are using the namespace ROOT::Math. </p><pre>SVector&gt;double,N&gt;  v;                         <em>// create a vector of size N, v[i]=0 </em>SVector&gt;double,3&gt;  v(1,2,3);                  <em>// create a vector of size 3, v[0]=1,v[1]=2,v[2]=3 </em>double   a[9] = {1,2,3,4,5,6,7,8,9};          <em>// input data</em>SVector&gt;double,9&gt;  v(a,9);                    <em>// create a vector using the a[] data</em>                 </pre><h3>Accessing and Setting Methods</h3>The single vector elements can be set or retrieved using the <em>operator[i]</em> , <em>operator(i)</em> or the iterator interface. Notice that the index starts from zero and not from one as in Fortran. Also no check is performed on the passed index.  The elements can be accessed also by using the ROOT::Math::SVector::apply(i) function. <pre> v[0]  = 1;                          <em> // set the first element </em> v(1)  = 2;                          <em> // set the second element </em>     *(v.<strong>begin</strong>()+3) = 3; <em>                 // set the third element </em>double x = m(i);                     <em>// return the i-th element</em>x = m.<strong>apply</strong>(i);                      <em>// return the i-th element </em>x = *(m.<strong>begin</strong>()+i);                  <em>// return the i-th element </em>                                  </pre>In addition there are methods to place a sub-vector in a vector. If the size of the the sub-vector is larger than the vector size a static assert ( a compilation error) is produced. <pre> SVector&gt;double,N&gt;  v;   SVector&gt;double,M&gt;  w;          <em>// M <= N otherwise a compilation error is obtained later </em>   <em>// place a vector of size M starting from element ioff,  v[ioff + i] = w[i]</em>v.<strong>Place_at</strong>(w,ioff); <em>// return a sub-vector of size M starting from v[ioff]:  w[i] = v[ioff + i]</em>w = v.Sub &lt; SVector&gt;double,M&gt; &gt; (ioff);</pre><h3>Vector Operators </h3><p>The ROOT::Math::SVector class defines the following operators. The (<em>v1,v2,v3</em>) are vectors of the same type and <em>a</em> is a scalar value </p><pre>v1 == v2           <em>// returns whether v1 is equal to v2 (element by element comparison) </em> v1 != v2           <em>// returns whether v1 is NOT equal to v2 (element by element comparison) </em> v1 &lt; v2            <em>// returns whether v1 is less than v2 (element wise comparison)</em>v1 &gt; v2            <em>// returns whether v1 is greater than v2 (element wise comparison)</em>v1 += v2           <em>// add v2 to v1</em>v1 -= v2           <em>// subtract v2 to v1 </em>v3 = v1 + v2       <em>// vector addition </em>v1 - v2            <em>// vector subtraction</em><em>// Multiplication and division via a scalar value a for all vector elements</em> v3 = a*v1; v3 = v1*a; v3 = v1/a;  </pre><h3>Vector Functions</h3>The major Vector functions are: <ul><li><strong>ROOT::Math::Dot</strong>( v1, v2) : returns the scalar value resulting from the vector dot product</li><li><strong>ROOT::Math::Cross</strong>( v1, v2) : returns the vector cross product for two vectors of size 3. Note that the Cross product is not defined for other vector sizes</li><li><strong>ROOT::Math::Unit</strong>( v) : returns unit vector. One can use also the <em>v.Unit()</em> method. </li><li><strong>ROOT::Math::TensorProd</strong>(v1,v2) : returns a general matrix M of size N1xN2 resulting from the <a href="http://en.wikipedia.org/wiki/Tensor_product">Tensor Product</a> between the vector v1 of size N1) and v2 of size N2 </li></ul>See \ref VectFunction for the  list and documentation of all of them. <h3>Other Functions</h3>One can print (or write in an output stream)  Vectors (and also Matrices) using the Print method or the << operator, like: <pre>v.Print(std::cout);std::cout << v << std::endl;</pre><br>*/