// Vector3d doxygen page

/**

  \page Vector3DPage  Vector3D Classes


The following types of Vector are defined by defaults: 

<ul>
<li>ROOT::Math::XYZVector  vector based on x,y,z coordinates (cartesian) in double precision
<li>ROOT::Math::XYZVectorF  vector based on x,y,z coordinates (cartesian) in float precision
<li>ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar) in double precision
<li>ROOT::Math::Polar3DVectorF vector based on r,theta,phi coordinates (polar) in float precision
<li>ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double precision
<li>ROOT::Math::RhoEtaPhiVectorF vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in float precision
</ul>
<p> 
<h4>Constructors and Assignment</h4>
The following declarations are available: 
<pre>
 XYZVector         v1;                     // create an empty vector (x = 0, y = 0, z = 0) 
 XYZVector         v2( 1,2,3);             // create a vector with x=1, y = 2, z = 3; 
 Polar3DVector     v3( 1, PI/2, PI);       // create a vector with r = 1, theta = PI/2 and phi=PI
 RhoEtaPHiVector   v4( 1, 2, PI)           // create a vector with rho= 1, eta = 2, phi = PI
</pre>
Note that each type of vector is constructed by passing its coordinates representations, so a XYZVector(1,2,3) is different from a 
Polar3DVector(1,2,3). 
<p>
In addition the Vector classes can be constructed by any vector, which implements the accessors x(), y() and z().   
This con be another Vector3D based on a different coordinate system types or even any vector of a different package, like the CLHEP HepThreeVector that implements the required signatures.  
<pre>
  XYZVector v1(1,2,3); 
  RhoEtaPHiVector r2(v1); 
  CLHEP::HepThreeVector q(1,2,3); 
  XYZVector v3(q)  
</pre>

<h4>Coordinate Accessors</h4>
To get information on the coordinates on the vector (cartesian, polar, cylindrical, etc...) see the documentation for the classe ROOT::Math::DisplacementVector3D.
<h4>Setter Methods</h4>
Setter methods as in CLHEP, setting each coordinate at a time are not supported. You can set only all the tree coordinates.
<ul>
<li> SetCoordinates( c1, c2, c3)  which sets the three basic coordinates, x,y,z for a XYZVector and r,theta,phi for a Polar3DVector. 
<li> SetXYZ ( x, y, z) which sets the three cartesian components. 
</ul>
In addition we have both get and setter methods from C arrays or iterators.
<pre>
double d[3] = {1.,2.,3.};
XYZVector v;
v.SetCoordinates(d);
double * d2; 
v.GetCoordinates(d2);
</pre>
or for example from an std::vector using the iterator
<pre>
std::vector<double> w(3);   
XYZVector v;
v.SetCoordinates(w.begin(),w.end());
std::vector<double> w2(3);  
v.GetCoordinates(w2.begin(),w2.end());
</pre>

<h4>Arithmetic Operations</h4>
The following operations are possible between Vectors classes, even of different coordinate system types: 
( v is a one of the Vector3D class, q is a generic Vector  implementing x(), y() and z() and a  is 
a generic scalar type: double, flot, int, etc.... )  
<pre>
v += q; 
v -= q; 
v1 *= a;
v1 /= a; 
</pre>
And for 3D Vector classes, the following operations are possibles: ( v1 and v2 can be two vectors in different coordinate system. v3 is the same type of v1)   
<pre>
v3 = v1 + v2;   
v3 = v1 - v2;  
v2 = a * v1;   
v2 = v1 * a;
v2 = v1 / a;   
</pre>
In addition we support the dot and cross products, through the Dot() and Cross() methods. 
Multiplication between two vectors using the operator * is not supported because is ambigous.

*/
