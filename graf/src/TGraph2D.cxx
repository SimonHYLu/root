// @(#)root/graf:$Name:  $:$Id: TGraph2D.cxx,v 1.00
// Author: Olivier Couet   23/10/03
// Author: Luke Jones (Royal Holloway, University of London) April 2002

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/

#include "Riostream.h"
#include "TROOT.h"
#include "TGraph2D.h"
#include "TMath.h"
#include "TPolyLine.h"
#include "TPolyMarker.h"
#include "TVirtualPad.h"
#include "TVirtualFitter.h"
#include "TView.h"

ClassImp(TGraph2D)

//______________________________________________________________________________
//
// A Graph2D is a graphics object made of three arrays X, Y and Z
// with the same number of points each.
//
// This class has three different constructors:
//
// 1) With an array dimension and three arrays x, y, and z:
//
//    TGraph2D *g = new TGraph2D(n, x, y, z);
//
// 2) With an array dimension only:
//
//    TGraph2D *g = new TGraph2D(n);
//
//    The internal arrays are then filled with SetPoint. The following line
//    fills the the internal arrays at the position "i" with the values x,y,z.
//
//    g->SetPoint(i,x,y,z);
//
// 3) Without parameters:
//
//    TGraph2D *g = new TGraph2D();
//
//    again SetPoint must be used to fill the internal arrays.
//
// Note that in any of these three cases, SetPoint can be used to change a data
// point or add a new one. If the data point index (i) is greater than the 
// current size of the internal arrays, they are automatically extended.
//
// Specific drawing options can be used to paint a TGraph2D:
//   "TRI"  : the Delaunay's triangles are drawn using filled area. 
//            An hidden surface drawing technique is used
//   "TRIW" : the Delaunay's triangles are drawn as wire frame
//   "P"    : draw a marker at each vertex
//
// A TGraph2D can be also drawn with ANY options valid to draw a 2D histogram. 
//
// When a TGraph2D is drawn with one of the 2D histogram drawing option,
// a intermediate 2D histogram is filled using the Delaunay triangles 
// technique to interpolate the data set. 
//
// TGraph2D linearly interpolate a Z value for any (X,Y) point given some 
// existing (X,Y,Z) points. The existing (X,Y,Z) points can be randomly 
// scattered. The algorithm work by joining the existing points to make 
// (Delaunay) triangles in (X,Y). These are then used to define flat planes 
// in (X,Y,Z) over which to interpolate. The interpolated surface thus takes 
// the form of tessellating triangles at various angles. Output can take the 
// form of a 2D histogram or a vector. The triangles found can be drawn in 3D.
//
// This software cannot be guaranteed to work under all circumstances. They 
// were originally written to work with a few hundred points in an XY space 
// with similar X and Y ranges.
//
//  The picture below has been generated by the following macro:
//
//{
//   TCanvas *c = new TCanvas("c","Graph2D example",0,0,700,600);
//   Double_t x, y, z, P = 6.;
//   Int_t np = 200;
//   TGraph2D *dt = new TGraph2D();
//   TRandom *r = new TRandom();
//   for (Int_t N=0; N<np; N++) {
//      x = 2*P*(r->Rndm(N))-P;
//      y = 2*P*(r->Rndm(N))-P;
//      z = (sin(x)/x)*(sin(y)/y)+0.2;
//      dt->SetPoint(N,x,y,z);
//   }
//   gStyle->SetPalette(1);
//   dt->Draw("surf1");
//}
//Begin_Html
/*
<img src="gif/graph2d.gif">
*/
//End_Html
//
// A more complete example can be find in $ROOTSYS/tutorial/graph2dfit.C. It
// produces the following output:
//
//Begin_Html
/*
<img src="gif/graph2dfit.gif">
*/
//End_Html


const Int_t kMaxStored    = 2500;
const Int_t kMaxNTris2Try = 100000;


//______________________________________________________________________________
TGraph2D::TGraph2D()
         : TNamed("Graph2D","Graph2D"), TAttLine(1,1,1), TAttFill(0,1001),
           TAttMarker(), fNpoints(0)
{
   // Graph2D default constructor

   Initialise(100);
}


//______________________________________________________________________________
TGraph2D::TGraph2D(Int_t n, Double_t *x, Double_t *y, Double_t *z, Option_t *)
         : TNamed("Graph2D","Graph2D"), TAttLine(1,1,1), TAttFill(0,1001),
           TAttMarker(), fNpoints(n)
{
   // Graph2D constructor with three vectors of doubles as input.

   Initialise(n);

   // Copy the input vectors into local arrays

   Int_t N;
   for (N=0; N<fNpoints; N++) {
      fX[N] = x[N];
      fY[N] = y[N];
      fZ[N] = z[N];
   }
}


//______________________________________________________________________________
TGraph2D::TGraph2D(Int_t n, Option_t *)
         : TNamed("Graph2D","Graph2D"), TAttLine(1,1,1), TAttFill(0,1001),
           TAttMarker(), fNpoints(0)
{
   // Graph2D constructor. The arrays fX, fY and fZ should be filled via
   // calls to SetPoint

   Initialise(n);
}


//______________________________________________________________________________
TGraph2D::TGraph2D(const char *filename, const char *format, Option_t *)
         : TNamed("Graph2D",filename), TAttLine(1,1,1), TAttFill(0,1001),
           TAttMarker(), fNpoints(0)
{
   // Graph2D constructor reading input from filename
   // filename is assumed to contain at least three columns of numbers
   
   Initialise(100);
  
   Double_t x,y,z;
   FILE *fp = fopen(filename,"r");
   if (!fp) {
      MakeZombie();   
      Error("TGraph2D", "Cannot open file: %s, TGraph2D is Zombie",filename);
      return;
   }
   char line[80];
   Int_t np = 0;
   while (fgets(line,80,fp)) {
      sscanf(&line[0],format,&x, &y, &z);
      SetPoint(np,x,y,z);
      np++;
   }
   
   fclose(fp);
}


//______________________________________________________________________________
TGraph2D::~TGraph2D()
{
   // TGraph2D destructor.

   if (fX) delete [] fX;
   if (fY) delete [] fY;
   if (fZ) delete [] fZ;
   if (fHistogram)  {delete fHistogram; fHistogram = 0;}
   if (fTried)      {delete [] fTried; fTried = 0;}
   if (fHullPoints) {delete [] fHullPoints; fHullPoints = 0;}
   if (fOrder)      {delete [] fOrder; fOrder = 0;}
   if (fDist)       {delete [] fDist; fDist = 0;}
   if (fXN)         {delete [] fXN; fXN = 0;}
   if (fYN)         {delete [] fYN; fYN = 0;}
   if (fFunctions) {
      fFunctions->SetBit(kInvalidObject);
      fFunctions->Delete();
      delete fFunctions;
      fFunctions = 0;
   }
}


//______________________________________________________________________________
Double_t TGraph2D::ComputeZ(Double_t xx, Double_t yy)
{
   // Finds the Delaunay triangle that the point (xx,yy) sits in (if any) and 
   // calculate a z-value for it by linearly interpolating the z-values that 
   // make up that triangle.

   Double_t thevalue;

   Int_t IT, ntris_tried, tri, P, N, M;
   Int_t I,J,K,L,Z,F,D,O1,O2,A,B,T1,T2,T3;
   Int_t ndegen=0,degen=0,fdegen=0,o1degen=0,o2degen=0;
   Int_t thistri;
   Double_t vxN,vyN;
   Double_t d1,d2,d3,c1,c2,dko1,dko2,dfo1;
   Double_t dfo2,sin_sum,cfo1k,co2o1k,co2o1f;

   Bool_t shouldbein;
   Double_t dx1,dx2,dx3,dy1,dy2,dy3,U,V,dxz[3],dyz[3];

   // create vectors needed for sorting
   if (!fOrder) {
      fOrder = new Int_t[fNpoints];
      fDist  = new Double_t[fNpoints];
   }

   // the input point will be point zero.
   fXN[0] = xx;
   fYN[0] = yy;

   // set the output value to the default value for now
   thevalue = fZout;

   // some counting
   ntris_tried = 0;

   // no point in proceeding if xx or yy are silly
   if ((xx>fXNmax) || (xx<fXNmin) || (yy>fYNmax) || (yy<fYNmin)) return thevalue;

   // check existing Delaunay triangles for a good one
   for (IT=1; IT<=fNdt; IT++) {
      if (fTried[IT-1] > 0) {
         tri = fTried[IT-1];
         P   = tri%1000;
         N   = ((tri%1000000)-P)/1000;
         M   = (tri-N*1000-P)/1000000;
         // P, N and M form a previously found Delaunay triangle, does it 
         // enclose the point?
         if (Enclose(P,N,M,0)) {
            // yes, we have the triangle
            thevalue = InterpolateOnPlane(P,N,M,0);
            return thevalue;
         }
      } else {
         Error("ComputeZ", "Negative/zero Delaunay triangle ? %d %d %g %g %d",IT,fNdt,xx,yy,fTried[IT-1]);
      }
   }

   // is this point inside the convex hull?
   shouldbein = InHull(0,-1);
   if (!shouldbein) return thevalue;

   // it must be in a Delaunay triangle - find it...

   // order mass points by distance in mass plane from desired point
   for (N=1; N<=fNpoints; N++) {
      vxN = fXN[N];
      vyN = fYN[N];
      fDist[N-1] = TMath::Sqrt((xx-vxN)*(xx-vxN)+(yy-vyN)*(yy-vyN));
   }

   // sort array 'dist' to find closest points
   TMath::Sort(fNpoints, fDist, fOrder, kFALSE);
   for (N=1; N<=fNpoints; N++) fOrder[N-1]++;

   // loop over triplets of close points to try to find a triangle that 
   // encloses the point.
   for (K=3; K<=fNpoints; K++) {
      M = fOrder[K-1];
      for (J=2; J<=K-1; J++) {
         N = fOrder[J-1];
         for (I=1; I<=J-1; I++) {
            P = fOrder[I-1];
            if (ntris_tried > kMaxNTris2Try) {
               // perhaps this point isn't in the hull after all
///            Warning("ComputeZ", 
///                    "Abandoning the effort to find a Delaunay triangle (and thus interpolated Z-value) for point %g %g"
///                    ,xx,yy);
               return thevalue;
            }
            ntris_tried++;
            // check the points aren't colinear
            d1 = TMath::Sqrt((fXN[P]-fXN[N])*(fXN[P]-fXN[N])+(fYN[P]-fYN[N])*(fYN[P]-fYN[N]));
            d2 = TMath::Sqrt((fXN[P]-fXN[M])*(fXN[P]-fXN[M])+(fYN[P]-fYN[M])*(fYN[P]-fYN[M]));
            d3 = TMath::Sqrt((fXN[N]-fXN[M])*(fXN[N]-fXN[M])+(fYN[N]-fYN[M])*(fYN[N]-fYN[M]));
            if ((d1+d2<=d3) || (d1+d3<=d2) || (d2+d3<=d1)) goto L90;

            // does the triangle enclose the point?
            if (!Enclose(P,N,M,0)) goto L90;

            // is it a Delaunay triangle? (ie. are there any other points 
            // inside the circle that is defined by its vertices?)

            // has this triangle already been tested for Delaunay'ness?
            tri = TriEncode(P,N,M);
            for (IT=kMaxStored-fNxt+1; IT<=kMaxStored; IT++) {
               if (tri == TMath::Abs(fTried[IT-1])) {
                  if (fTried[IT-1] < 0) {
                     // yes, and it is not a Delaunay triangle, forget about it
                     goto L90;
                  } else {
                     Error("ComputeZ", "Positive non-Delaunay triangle ? %g %g %d %d %d",
                           xx,yy,IT,fNxt,fNdt);
                     thevalue  = InterpolateOnPlane(P,N,M,0);
                     return thevalue;
                  }
               }
            }

            // test the triangle for Delaunay'ness

            thistri = tri;

            // loop over all other points testing each to see if it's 
            // inside the triangle's circle
            ndegen = 0;
            for ( Z=1; Z<=fNpoints; Z++) {
               if ((Z==P) || (Z==N) || (Z==M)) goto L50;
               // An easy first check is to see if point Z is inside the triangle 
               // (if it's in the triangle it's also in the circle)

               // point Z cannot be inside the triangle if it's further from (xx,yy) 
               // than the furthest pointing making up the triangle - test this
               for (L=1; L<=fNpoints; L++) {
                  if (fOrder[L-1] == Z) {
                     if ((L<I) || (L<J) || (L<K)) {
                        // point Z is nearer to (xx,yy) than M, N or P - it could be in the 
                        // triangle so call enclose to find out
                        if (Enclose(P,N,M,Z)) {
                           // it is inside the triangle and so this can't be a Del' triangle
                           FileIt(-thistri);
                           goto L90;
                        }
                     } else {
                        // there's no way it could be in the triangle so there's no point 
                        // calling enclose
                        goto L1;
                     }
                  }
               }
               // is point Z colinear with any pair of the triangle points?
L1:
               if (((fXN[P]-fXN[Z])*(fYN[P]-fYN[N])) == ((fYN[P]-fYN[Z])*(fXN[P]-fXN[N]))) {
                  // Z is colinear with P and N
                  A = P;
                  B = N;
               } else if (((fXN[P]-fXN[Z])*(fYN[P]-fYN[M])) == ((fYN[P]-fYN[Z])*(fXN[P]-fXN[M]))) {
                  // Z is colinear with P and M
                  A = P;
                  B = M;
               } else if (((fXN[N]-fXN[Z])*(fYN[N]-fYN[M])) == ((fYN[N]-fYN[Z])*(fXN[N]-fXN[M]))) {
                  // Z is colinear with N and M
                  A = N;
                  B = M;
               } else {
                  A = 0;
                  B = 0;
               }
               if (A != 0) {
                  // point Z is colinear with 2 of the triangle points, if it lies 
                  // between them it's in the circle otherwise it's outside
                  if (fXN[A] != fXN[B]) {
                     if (((fXN[Z]-fXN[A])*(fXN[Z]-fXN[B])) < 0) {
                        FileIt(-thistri);
                        goto L90;
                     } else if (((fXN[Z]-fXN[A])*(fXN[Z]-fXN[B])) == 0) {
                        // At least two points are sitting on top of each other, we will
                        // treat these as one and not consider this a 'multiple points lying
                        // on a common circle' situation. It is a sign something could be
                        // wrong though, especially if the two coincident points have
                        // different fZ's. If they don't then this is harmless.
                        Warning("ComputeZ", "Two of these three points are coincident %d %d %d",A,B,Z);
                     }
                  } else {
                     if (((fYN[Z]-fYN[A])*(fYN[Z]-fYN[B])) < 0) {
                        FileIt(-thistri);
                        goto L90;
                     } else if (((fYN[Z]-fYN[A])*(fYN[Z]-fYN[B])) == 0) {
                        // At least two points are sitting on top of each other - see above.
                        Warning("ComputeZ", "Two of these three points are coincident %d %d %d",A,B,Z);
                     }
                  }
                  // point is outside the circle, move to next point
                  goto L50;
               }

               // if point Z were to look at the triangle, which point would it see 
               // lying between the other two? (we're going to form a quadrilateral 
               // from the points, and then demand certain properties of that
               // quadrilateral)
               dxz[0] = fXN[P]-fXN[Z];
               dyz[0] = fYN[P]-fYN[Z];
               dxz[1] = fXN[N]-fXN[Z];
               dyz[1] = fYN[N]-fYN[Z];
               dxz[2] = fXN[M]-fXN[Z];
               dyz[2] = fYN[M]-fYN[Z];
               for(L=1; L<=3; L++) {
                  dx1 = dxz[L-1];
                  dx2 = dxz[L%3];
                  dx3 = dxz[(L+1)%3];
                  dy1 = dyz[L-1];
                  dy2 = dyz[L%3];
                  dy3 = dyz[(L+1)%3];

                  U = (dy3*dx2-dx3*dy2)/(dy1*dx2-dx1*dy2);
                  V = (dy3*dx1-dx3*dy1)/(dy2*dx1-dx2*dy1);

                  if ((U>=0) && (V>=0)) {
                     // vector (dx3,dy3) is expressible as a sum of the other two vectors 
                     // with positive coefficents -> i.e. it lies between the other two vectors
                     if (L == 1) {
                        F  = M;
                        O1 = P;
                        O2 = N;
                     } else if (L == 2) {
                        F  = P;
                        O1 = N;
                        O2 = M;
                     } else {
                        F  = N;
                        O1 = M;
                        O2 = P;
                     }
                     goto L2;
                  }
               }
               Error("ComputeZ", "Should not get to here");
               // may as well soldier on
               F  = M;
               O1 = P;
               O2 = N;
L2:
               // this is not a valid quadrilateral if the diagonals don't cross, 
               // check that points F and Z lie on opposite side of the line O1-O2,
               // this is true if the angle F-O1-Z is greater than O2-O1-Z and O2-O1-F
               cfo1k  = ((fXN[F]-fXN[O1])*(fXN[Z]-fXN[O1])+(fYN[F]-fYN[O1])*(fYN[Z]-fYN[O1]))/
                        TMath::Sqrt(((fXN[F]-fXN[O1])*(fXN[F]-fXN[O1])+(fYN[F]-fYN[O1])*(fYN[F]-fYN[O1]))*
                        ((fXN[Z]-fXN[O1])*(fXN[Z]-fXN[O1])+(fYN[Z]-fYN[O1])*(fYN[Z]-fYN[O1])));
               co2o1k = ((fXN[O2]-fXN[O1])*(fXN[Z]-fXN[O1])+(fYN[O2]-fYN[O1])*(fYN[Z]-fYN[O1]))/
                        TMath::Sqrt(((fXN[O2]-fXN[O1])*(fXN[O2]-fXN[O1])+(fYN[O2]-fYN[O1])*(fYN[O2]-fYN[O1]))*
                        ((fXN[Z]-fXN[O1])*(fXN[Z]-fXN[O1])  + (fYN[Z]-fYN[O1])*(fYN[Z]-fYN[O1])));
               co2o1f = ((fXN[O2]-fXN[O1])*(fXN[F]-fXN[O1])+(fYN[O2]-fYN[O1])*(fYN[F]-fYN[O1]))/
                        TMath::Sqrt(((fXN[O2]-fXN[O1])*(fXN[O2]-fXN[O1])+(fYN[O2]-fYN[O1])*(fYN[O2]-fYN[O1]))*
                        ((fXN[F]-fXN[O1])*(fXN[F]-fXN[O1]) + (fYN[F]-fYN[O1])*(fYN[F]-fYN[O1]) ));
               if ((cfo1k>co2o1k) || (cfo1k>co2o1f)) {
                  // not a valid quadrilateral - point Z is definitely outside the circle
                  goto L50;
               }
               // calculate the 2 internal angles of the quadrangle formed by joining
               // points Z and F to points O1 and O2, at Z and F. If they sum to less
               // than 180 degrees then Z lies outside the circle
               dko1    = TMath::Sqrt((fXN[Z]-fXN[O1])*(fXN[Z]-fXN[O1])+(fYN[Z]-fYN[O1])*(fYN[Z]-fYN[O1]));
               dko2    = TMath::Sqrt((fXN[Z]-fXN[O2])*(fXN[Z]-fXN[O2])+(fYN[Z]-fYN[O2])*(fYN[Z]-fYN[O2]));
               dfo1    = TMath::Sqrt((fXN[F]-fXN[O1])*(fXN[F]-fXN[O1])+(fYN[F]-fYN[O1])*(fYN[F]-fYN[O1]));
               dfo2    = TMath::Sqrt((fXN[F]-fXN[O2])*(fXN[F]-fXN[O2])+(fYN[F]-fYN[O2])*(fYN[F]-fYN[O2]));
               c1      = ((fXN[Z]-fXN[O1])*(fXN[Z]-fXN[O2])+(fYN[Z]-fYN[O1])*(fYN[Z]-fYN[O2]))/dko1/dko2;
               c2      = ((fXN[F]-fXN[O1])*(fXN[F]-fXN[O2])+(fYN[F]-fYN[O1])*(fYN[F]-fYN[O2]))/dfo1/dfo2;
               sin_sum = c1*TMath::Sqrt(1-c2*c2)+c2*TMath::Sqrt(1-c1*c1);

               // When being called from paw, sin_sum doesn't always come out as zero 
               // when it should do.
               if (sin_sum < -1.E-6) {
                  // Z is inside the circle, this is not a Delaunay triangle
                  FileIt(-thistri);
                  goto L90;
               } else if (TMath::Abs(sin_sum) <= 1.E-6) {
                  // point Z lies on the circumference of the circle (within rounding errors) 
                  // defined by the triangle, so there is potential for degeneracy in the 
                  // triangle set (Delaunay triangulation does not give a unique way to split
                  // a polygon whose points lie on a circle into constituent triangles). Make
                  // a note of the additional point number.
                  ndegen++;
                  degen   = Z;
                  fdegen  = F;
                  o1degen = O1;
                  o2degen = O2;
               }
L50:
            continue;
            }
            // This is a good triangle
            if (ndegen > 0) {
               // but is degenerate with at least one other,
               // haven't figured out what to do if more than 4 points are involved
               if (ndegen > 1) {
                  Error("ComputeZ", 
                        "More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d",
                        P,N,M,degen);
                  return thevalue;
               }

               // we have a quadrilateral which can be split down either diagonal
               // (D<->F or O1<->O2) to form valid Delaunay triangles. Choose diagonal
               // with highest average z-value. Whichever we choose we will have
               // verified two triangles as good and two as bad, only note the good ones
               D  = degen;
               F  = fdegen;
               O1 = o1degen;
               O2 = o2degen;
               if ((fZ[O1-1]+fZ[O2-1]) > (fZ[D-1]+fZ[F-1])) {
                  // best diagonalisation of quadrilateral is current one, we have 
                  // the triangle
                  T1 = P;
                  T2 = N;
                  T3 = M;
                  // file the good triangles as good
                  FileIt(thistri);
                  tri = TriEncode(D,O1,O2);
                  FileIt(tri);
               } else {
                  // use other diagonal to split quadrilateral, use triangle formed by 
                  // point F, the degnerate point D and whichever of O1 and O2 create 
                  // an enclosing triangle
                  T1 = F;
                  T2 = D;
                  if (Enclose(F,D,O1,0)) {
                     T3 = O1;
                  } else {
                     T3 = O2;
                  }
                  // file the good triangles as good and the original one as bad
                  FileIt(-thistri);
                  tri = TriEncode(F,D,O1);
                  FileIt(tri);
                  tri = TriEncode(F,D,O2);
                  FileIt(tri);
               }
            } else {
               // this is a Delaunay triangle, file it as such
               FileIt(thistri);
               T1 = P;
               T2 = N;
               T3 = M;
            }
            // do the interpolation
            thevalue = InterpolateOnPlane(T1,T2,T3,0);
            return thevalue;
L90:
            continue;
         }
      }
   }
   if (shouldbein) {
      Error("ComputeZ", 
            "Point outside hull when expected inside: this point could be dodgy %g %g %d",
             xx, yy, ntris_tried);
   }
   return thevalue;
}


//______________________________________________________________________________
Int_t TGraph2D::DistancetoPrimitive(Int_t px, Int_t py)
{
   // Computes distance from point px,py to a graph

   Int_t distance = 9999;
   if (fHistogram) distance = fHistogram->DistancetoPrimitive(px,py);
   return distance;
}


//______________________________________________________________________________
Bool_t TGraph2D::Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const
{
   // Is point E inside the triangle T1-T2-T3 ?

   Int_t E=0,A=0,B=0;
   Double_t dx1,dx2,dx3,dy1,dy2,dy3,U,V;

   Bool_t enclose = kFALSE;

   E = TMath::Abs(Ex);
      
   // First ask if point E is colinear with any pair of the triangle points
   A = 0;
   if (((fXN[T1]-fXN[E])*(fYN[T1]-fYN[T2])) == ((fYN[T1]-fYN[E])*(fXN[T1]-fXN[T2]))) {
   //     E is colinear with T1 and T2
      A = T1;
      B = T2;
   } else if (((fXN[T1]-fXN[E])*(fYN[T1]-fYN[T3])) == ((fYN[T1]-fYN[E])*(fXN[T1]-fXN[T3]))) {
   //     E is colinear with T1 and T3
      A = T1;
      B = T3;
   } else if (((fXN[T2]-fXN[E])*(fYN[T2]-fYN[T3])) == ((fYN[T2]-fYN[E])*(fXN[T2]-fXN[T3]))) {
   //     E is colinear with T2 and T3
      A = T2;
      B = T3;
   }
   if (A != 0) {
   //     point E is colinear with 2 of the triangle points, if it lies 
   //     between them it's in the circle otherwise it's outside
      if (fXN[A] != fXN[B]) {
         if (((fXN[E]-fXN[A])*(fXN[E]-fXN[B])) <= 0) {
            enclose = kTRUE;
            return enclose;
         }
      } else {
         if (((fYN[E]-fYN[A])*(fYN[E]-fYN[B])) <= 0) {
            enclose = kTRUE;
            return enclose;
         }
      }
   //     point is outside the triangle
      return enclose;
   }

   // E is not colinear with any pair of triangle points, if it is inside
   // the triangle then the vector from E to one of the corners must be 
   // expressible as a sum with positive coefficients of the vectors from 
   // the two other corners to E. Say vector3=U*vector1+V*vector2

   // vector1==T1->E
   dx1 = fXN[E]-fXN[T1];
   dy1 = fYN[E]-fYN[T1];
   // vector2==T2->E
   dx2 = fXN[E]-fXN[T2];
   dy2 = fYN[E]-fYN[T2];
   // vector3==E->T3
   dx3 = fXN[T3]-fXN[E];
   dy3 = fYN[T3]-fYN[E];

   U = (dx2*dy3-dx3*dy2)/(dx2*dy1-dx1*dy2);
   V = (dx1*dy3-dx3*dy1)/(dx1*dy2-dx2*dy1);

   if ((U>=0) && (V>=0)) enclose = kTRUE;

   return enclose;
}


//______________________________________________________________________________
void TGraph2D::ExecuteEvent(Int_t event, Int_t px, Int_t py)
{   
   // Executes action corresponding to one event

   if (fHistogram) fHistogram->ExecuteEvent(event, px, py);
}


//______________________________________________________________________________
void TGraph2D::FileIt(Int_t tri)
{
   // Files the triangle 'tri' in the fTried array. Delaunay triangles 
   // (tri>0) are stored sequentially from fTried[0] onwards. Non-Delaunay 
   // triangles are stored sequentially from fTried[kMaxStored-1] backwards. 
   // If the array cannot hold all the triangles, Delaunay triangles get 
   // priority - non-Delaunay triangles are overwritten and subsequent 
   // non-Delaunay triangles overwrite previous non-Delaunay triangles.

   if (tri > 0) {
      // store a new Delaunay triangle
      fNdt++;
      if (fNdt> kMaxStored) {
         Error("FileIt", 
               "No space left in fTried, the kMaxStored parameter should be increased %d",
               tri);
      } else {
         fTried[fNdt-1] = tri;
      }
      // we may have overwritten a non-Delaunay triangle - update fNxt
      fNxt = TMath::Min(kMaxStored-fNdt,fNxt);
   } else if ((kMaxStored-fNxt) > fNdt) {
      // store a new non-Delaunay triangle - we have space to do this without 
      // overwriting anything
      fTried[kMaxStored-fNxt-1] = tri;
      fNxt++;
   } else if (kMaxStored > fNdt) {
      // store a new non-Delaunay triangle - there is still space to do this 
      // but we will have to overwrite old non-Delaunay triangles
      fTried[kMaxStored-1] = tri;
      fNxt = 1;
   }
}


//______________________________________________________________________________
void TGraph2D::FindAllTriangles()
{
   // Attempt to find all the Delaunay triangles of 
   // the point set. It is not guaranteed that it will fully 
   // succeed, and no check is made that it has fully succeeded (such 
   // a check would be possible by referencing the points that make up 
   // the convex hull). The method is to check if each triangle shares 
   // all three of its sides with other triangles. If not, a point is 
   // generated just outside the triangle on the side(s) not shared, 
   // and a new triangle is found for that point. If you find the 
   // routine is not working properly (many triangles are not being 
   // found) it's probably because the new points are too far beyond or
   // too close to the non-shared sides. You can try fiddling with the 
   // size of the `alittlebit' parameter.

   Double_t xcntr,ycntr,z,xc,yc,xm,ym,xx,yy;
   Double_t sx,sy,nx,ny,mx,my,mdotn,nn,A;
   Int_t T1,T2,Pa,Na,Ma,Pb,Nb,Mb,Sa[3],Sb[3],P1,P2,M,N,P3=0;
   Bool_t s[3];
   Double_t alittlebit = 0.0001;


   // start with a point that is guaranteed to be inside the hull (the 
   // centre of the hull)
   xcntr = 0;
   ycntr = 0;
   for (N=1; N<=fNhull; N++) {
      xcntr = xcntr+fXN[fHullPoints[N-1]];
      ycntr = ycntr+fYN[fHullPoints[N-1]];
   }
   xcntr = xcntr/fNhull;
   ycntr = ycntr/fNhull;
   // and calculate it's triangle
   z = ComputeZ(xcntr,ycntr);

   // loop over all Delaunay triangles (including those constantly being 
   // produced within the loop) and check to see if their 3 sides also 
   // correspond to the sides of other Delaunay triangles, i.e. that they 
   // have all their neighbours.
   T1 = 1;
   while (T1 <= fNdt) {
      if (fTried[T1-1] > 0) {
         // get the three points that make up this triangle
         Pa = (Int_t)(fTried[T1-1]/1000000);
         Na = ((Int_t)(fTried[T1-1]/1000))%1000;
         Ma = fTried[T1-1]%1000;

         // produce three integers which will represent the three sides
         Sa[0] = Pa*1000+Na;
         Sa[1] = Pa*1000+Ma;
         Sa[2] = Na*1000+Ma;
         s[0]  = kFALSE;
         s[1]  = kFALSE;
         s[2]  = kFALSE;
         // loop over all other Del' triangles
         for (T2=1; T2<=fNdt; T2++) {
            if (fTried[T2-1] > 0 && T2 != T1) {
               // get the points that make up this triangle
               Pb = (Int_t)(fTried[T2-1]/1000000.);
               Nb = ((Int_t)(fTried[T2-1]/1000.))%1000;
               Mb = fTried[T2-1]%1000;
               // and generate integers which represent its sides
               // (note that Mb>Nb>Pb - see routine triencode)
               Sb[0] = Pb*1000+Nb;
               Sb[1] = Pb*1000+Mb;
               Sb[2] = Nb*1000+Mb;

               // do triangles T1 and T2 share a side?
               if ((Sa[0]==Sb[0]) || (Sa[0]==Sb[1]) || (Sa[0]==Sb[2])) {
                  // they share side 1
                  s[0] = kTRUE;
               } else if ((Sa[1]==Sb[0]) || (Sa[1]==Sb[1]) || (Sa[1]==Sb[2])) {
                  // they share side 2
                  s[1] = kTRUE;
               } else if ((Sa[2]==Sb[0]) || (Sa[2]==Sb[1]) || (Sa[2]==Sb[2])) {
                  // they share side 3
                  s[2] = kTRUE;
               }
            }
            // if T1 shares all its sides with other Del' triangles then 
            // forget about it
            if (s[0] && s[1] && s[2]) continue;
         }
         // Looks like T1 is missing a neighbour on at least one side.
         // For each side, take a point a little bit beyond it and calculate 
         // the Del' triangle for that point, this should be the triangle 
         // which shares the side.
         xc = (fXN[Pa]+fXN[Na]+fXN[Ma])/3.;
         yc = (fYN[Pa]+fYN[Na]+fYN[Ma])/3.;
         for (M=1; M<=3; M++) {
            if (!s[M-1]) {
               // get the two points that make up this side
               P1 = (Int_t)(Sa[M-1]/1000.);
               P2 = Sa[M-1]%1000;
               // get the coordinates of the centre of this side
               xm = (fXN[P1]+fXN[P2])/2.;
               ym = (fYN[P1]+fYN[P2])/2.;
               // we want to add a little to these coordinates to get a point just
               // outside the triangle; (sx,sy) will be the vector that represents 
               // the side
               sx = fXN[P1]-fXN[P2];
               sy = fYN[P1]-fYN[P2];
               // (nx,ny) will be the normal to the side, but don't know if it's 
               // pointing in or out yet
               nx = sy;
               ny = -sx;
               nn = TMath::Sqrt(nx*nx+ny*ny);
               nx = nx/nn;
               ny = ny/nn;
               if (M == 1) {
                  P3 = Ma;
               } else if (M == 2) {
                  P3 = Na;
               } else if (M == 3) {
                  P3 = Pa;
               }
               mx    = fXN[P3]-xm;
               my    = fYN[P3]-ym;
               mdotn = mx*nx+my*ny;
               if (mdotn > 0) {
                  // (nx,ny) is pointing in, we want it pointing out
                  nx = -nx;
                  ny = -ny;
               }
               // increase/decrease xm and ym a little to produce a point 
               // just outside the triangle (ensuring that the amount added will 
               // be large enough such that it won't be lost in rounding errors)
               A  = TMath::Abs(TMath::Max(alittlebit*xm,alittlebit*ym));
               xx = xm+nx*A;
               yy = ym+ny*A;
               // try and find a new Delaunay triangle for this point
               z = ComputeZ(xx,yy);
               // this side of T1 should now, hopefully, if it's not part of the 
               // hull, be shared with a new Del' triangle just calculated by ComputeZ
            }
         }
      }
      T1++;
   }
}      


//______________________________________________________________________________
void TGraph2D::FindHull()
{
   // Finds those points which make up the convex hull of the set. If the xy
   // plane were a sheet of wood, and the points were nails hammered into it
   // at the respective coordinates, then if an elastic band were stretched
   // over all the nails it would form the shape of the convex hull. Those
   // nails in contact with it are the points that make up the hull.

   Int_t N,nhull_tmp;
   Bool_t in;

   if (!fHullPoints) fHullPoints = new Int_t[fNpoints];

   nhull_tmp = 0;
   for(N=1; N<=fNpoints; N++) {
      // if the point is not inside the hull of the set of all points 
      // bar it, then it is part of the hull of the set of all points 
      // including it
      in = InHull(N,N);
      if (!in) {
         // cannot increment fNhull directly - InHull needs to know that 
         // the hull has not yet been completely found
         nhull_tmp++;
         fHullPoints[nhull_tmp-1] = N;
      }
   }
   fNhull = nhull_tmp;
}


//______________________________________________________________________________
Bool_t TGraph2D::InHull(Int_t E, Int_t X) const
{
   // Is point E inside the hull defined by all points apart from X ?

   Int_t n1,n2,N,M,Ntry;
   Double_t lastdphi,dd1,dd2,dx1,dx2,dx3,dy1,dy2,dy3;
   Double_t U,V,vNv1,vNv2,phi1,phi2,dphi,xx,yy;

   Bool_t DTinhull = kFALSE;

   xx = fXN[E];
   yy = fYN[E];

   if (fNhull > 0) {
      //  The hull has been found - no need to use any points other than 
      //  those that make up the hull
      Ntry = fNhull;
   } else {
      //  The hull has not yet been found, will have to try every point
      Ntry = fNpoints;
   }

   //  N1 and N2 will represent the two points most separated by angle
   //  from point E. Initially the angle between them will be <180 degs.
   //  But subsequent points will increase the N1-E-N2 angle. If it 
   //  increases above 180 degrees then point E must be surrounded by 
   //  points - it is not part of the hull.
   n1 = 1;
   n2 = 2;
   if (n1 == X) {
      n1 = n2;
      n2++;
   } else if (n2 == X) {
      n2++;
   }

   //  Get the angle N1-E-N2 and set it to lastdphi
   dx1  = xx-fXN[n1];
   dy1  = yy-fYN[n1];
   dx2  = xx-fXN[n2];
   dy2  = yy-fYN[n2];
   phi1 = TMath::ATan2(dy1,dx1);
   phi2 = TMath::ATan2(dy2,dx2);
   dphi = (phi1-phi2)-((Int_t)((phi1-phi2)/TMath::TwoPi())*TMath::TwoPi());
   if (dphi < 0) dphi = dphi+TMath::TwoPi();
   lastdphi = dphi;
   for (N=1; N<=Ntry; N++) {
      if (fNhull > 0) {
         // Try hull point N
         M = fHullPoints[N-1];
      } else {
         M = N;
      }
      if ((M!=n1) && (M!=n2) && (M!=X)) {
         // Can the vector E->M be represented as a sum with positive 
         // coefficients of vectors E->N1 and E->N2?
         dx1 = xx-fXN[n1];
         dy1 = yy-fYN[n1];
         dx2 = xx-fXN[n2];
         dy2 = yy-fYN[n2];
         dx3 = xx-fXN[M];
         dy3 = yy-fYN[M];

         dd1 = (dx2*dy1-dx1*dy2);
         dd2 = (dx1*dy2-dx2*dy1);

         if (dd1*dd2!=0) {
            U = (dx2*dy3-dx3*dy2)/dd1;
            V = (dx1*dy3-dx3*dy1)/dd2;
            if ((U<0) || (V<0)) {
               // No, it cannot - point M does not lie inbetween N1 and N2 as 
               // viewed from E. Replace either N1 or N2 to increase the 
               // N1-E-N2 angle. The one to replace is the one which makes the
               // smallest angle with E->M
               vNv1 = (dx1*dx3+dy1*dy3)/TMath::Sqrt(dx1*dx1+dy1*dy1);
               vNv2 = (dx2*dx3+dy2*dy3)/TMath::Sqrt(dx2*dx2+dy2*dy2);
               if (vNv1 > vNv2) {
                  n1   = M;
                  phi1 = TMath::ATan2(dy3,dx3);
                  phi2 = TMath::ATan2(dy2,dx2);
               } else {
                  n2   = M;
                  phi1 = TMath::ATan2(dy1,dx1);
                  phi2 = TMath::ATan2(dy3,dx3);
               }
               dphi = (phi1-phi2)-((Int_t)((phi1-phi2)/TMath::TwoPi())*TMath::TwoPi());
               if (dphi < 0) dphi = dphi+TMath::TwoPi();
               if (((dphi-TMath::Pi())*(lastdphi-TMath::Pi())) < 0) {
                  // The addition of point M means the angle N1-E-N2 has risen 
                  // above 180 degs, the point is in the hull.
                  goto L10;
               }
               lastdphi = dphi;
            }
         }
      }
   }
   // Point E is not surrounded by points - it is not in the hull.
   goto L999;
L10:
   DTinhull = kTRUE;
L999:
   return DTinhull;
}


//______________________________________________________________________________
void TGraph2D::Initialise(Int_t n)
{
   // Initialises the data structures needed to compute the Delaunay triangles

   fSize   = n,
   fMargin = 0.;
   fNpx    = 40;
   fNpy    = 40;
   fZout   = 0.;

   fNdt        = 0;
   fNxt        = 0;
   fNhull      = 0;
   fFunctions  = 0;
   fHistogram  = 0;
   fMaximum    = -1111;
   fMinimum    = -1111;
   fHullPoints = 0;
   fXN         = 0;
   fYN         = 0;
   fOrder      = 0;
   fDist       = 0;

   fTried = new Int_t[kMaxStored];
   
   fX = new Double_t[fSize];
   fY = new Double_t[fSize];
   fZ = new Double_t[fSize];

   fFunctions = new TList;
}

//______________________________________________________________________________
Double_t TGraph2D::Interpolate(Double_t x, Double_t y) const
{
   // Finds the z value at the position (x,y) thanks to 
   // the Delaunay interpolation.

   if (!fXN) {
      Double_t xmax = GetXmax();
      Double_t ymax = GetYmax();
      Double_t xmin = GetXmin();
      Double_t ymin = GetYmin();
      ((TGraph2D*)this)->fXoffset = -(xmax+xmin)/2.;
      ((TGraph2D*)this)->fYoffset = -(ymax+ymin)/2.;
      ((TGraph2D*)this)->fScaleFactor = 2./((xmax-xmin)+(ymax-ymin));
      ((TGraph2D*)this)->fXNmax = (xmax+fXoffset)*fScaleFactor;
      ((TGraph2D*)this)->fXNmin = (xmin+fXoffset)*fScaleFactor;
      ((TGraph2D*)this)->fYNmax = (ymax+fYoffset)*fScaleFactor;
      ((TGraph2D*)this)->fYNmin = (ymin+fYoffset)*fScaleFactor;
      ((TGraph2D*)this)->fXN    = new Double_t[fNpoints+1];
      ((TGraph2D*)this)->fYN    = new Double_t[fNpoints+1];
      for (Int_t N=0; N<fNpoints; N++) {
         fXN[N+1] = (fX[N]+fXoffset)*fScaleFactor;
         fYN[N+1] = (fY[N]+fYoffset)*fScaleFactor;
      }
   }
   Double_t sx = (x+fXoffset)*fScaleFactor;
   Double_t sy = (y+fYoffset)*fScaleFactor;
   return ((TGraph2D*)this)->ComputeZ(sx, sy);
}

//______________________________________________________________________________
Double_t TGraph2D::InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const
{
   // Finds the z-value at point E given that it lies 
   // on the plane defined by T1,T2,T3

   Int_t tmp;
   Bool_t swap;
   Double_t x1,x2,x3,y1,y2,y3,f1,f2,f3,U,V,W;

   Int_t T1 = TI1;
   Int_t T2 = TI2;
   Int_t T3 = TI3;

L1:
   swap = kFALSE;
   if (T2 > T1) { tmp = T1; T1 = T2; T2 = tmp; swap = kTRUE;}
   if (T3 > T2) { tmp = T2; T2 = T3; T3 = tmp; swap = kTRUE;}
   if (swap) goto L1;

   x1 = fXN[T1];
   x2 = fXN[T2];
   x3 = fXN[T3];
   y1 = fYN[T1];
   y2 = fYN[T2];
   y3 = fYN[T3];
   f1 = fZ[T1-1];
   f2 = fZ[T2-1];
   f3 = fZ[T3-1];
   U  = (f1*(y2-y3)+f2*(y3-y1)+f3*(y1-y2))/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2));
   V  = (f1*(x2-x3)+f2*(x3-x1)+f3*(x1-x2))/(y1*(x2-x3)+y2*(x3-x1)+y3*(x1-x2));
   W  = f1-U*x1-V*y1;

   return U*fXN[E]+V*fYN[E]+W;
}


//______________________________________________________________________________
TObject *TGraph2D::FindObject(const char *name) const
{
   // search object named name in the list of functions

   if (fFunctions) return fFunctions->FindObject(name);
   return 0;
}


//______________________________________________________________________________
TObject *TGraph2D::FindObject(const TObject *obj) const
{
   // search object obj in the list of functions 

   if (fFunctions) return fFunctions->FindObject(obj);
   return 0;
}


//______________________________________________________________________________
Int_t TGraph2D::Fit(const char *fname, Option_t *option, Option_t *)
{
   // Fits this graph with function with name fname

   TF2 *f2 = (TF2*)gROOT->GetFunction(fname);
   if (!f2) {
      Error("Fit","Unknown function: %s",fname);
      return -1;
   }
   return Fit(f2,option,"");
}


//______________________________________________________________________________
Int_t TGraph2D::Fit(TF2 *f2, Option_t *option, Option_t *)
{
   // Fits this 2D graph with function f2
   //
   //  f2 is an already predefined function created by TF2.
   //  Predefined functions such as gaus, expo and poln are automatically
   //  created by ROOT.
   //
   //  The list of fit options is given in parameter option.
   //     option = "W"  Set all errors to 1
   //            = "U" Use a User specified fitting algorithm (via SetFCN)
   //            = "Q" Quiet mode (minimum printing)
   //            = "V" Verbose mode (default is between Q and V)
   //            = "R" Use the Range specified in the function range
   //            = "N" Do not store the graphics function, do not draw
   //            = "0" Do not plot the result of the fit. By default the fitted function
   //                  is drawn unless the option"N" above is specified.
   //            = "+" Add this new fitted function to the list of fitted functions
   //                  (by default, any previous function is deleted)
   //
   //  In order to use the Range option, one must first create a function
   //  with the expression to be fitted. For example, if your graph2d
   //  has a defined range between -4 and 4 and you want to fit a gaussian
   //  only in the interval 1 to 3, you can do:
   //       TF2 *f2 = new TF2("f2","gaus",1,3);
   //       graph2d->Fit("f2","R");
   //
   //
   //  Setting initial conditions
   //  ==========================
   //  Parameters must be initialized before invoking the Fit function.
   //  The setting of the parameter initial values is automatic for the
   //  predefined functions : poln, expo, gaus. One can however disable
   //  this automatic computation by specifying the option "B".
   //  You can specify boundary limits for some or all parameters via
   //       f2->SetParLimits(p_number, parmin, parmax);
   //  if parmin>=parmax, the parameter is fixed
   //  Note that you are not forced to fix the limits for all parameters.
   //  For example, if you fit a function with 6 parameters, you can do:
   //    func->SetParameters(0,3.1,1.e-6,0.1,-8,100);
   //    func->SetParLimits(4,-10,-4);
   //    func->SetParLimits(5, 1,1);
   //  With this setup, parameters 0->3 can vary freely
   //  Parameter 4 has boundaries [-10,-4] with initial value -8
   //  Parameter 5 is fixed to 100.
   //
   //  Fit range
   //  =========
   //  The fit range can be specified in two ways:
   //    - specify rxmax > rxmin (default is rxmin=rxmax=0)
   //    - specify the option "R". In this case, the function will be taken
   //      instead of the full graph range.
   //
   //  Changing the fitting function
   //  =============================
   //  By default the fitting function Graph2DFitChisquare is used.
   //  To specify a User defined fitting function, specify option "U" and
   //  call the following functions:
   //    TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction)
   //  where MyFittingFunction is of type:
   //  extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);
   //
   //  Associated functions
   //  ====================
   //  One or more object (typically a TF2*) can be added to the list
   //  of functions (fFunctions) associated to each graph.
   //  When TGraph::Fit is invoked, the fitted function is added to this list.
   //  Given a graph gr, one can retrieve an associated function
   //  with:  TF2 *myfunc = gr->GetFunction("myfunc");
   //
   //  Access to the fit results
   //  =========================
   //  If the graph is made persistent, the list of
   //  associated functions is also persistent. Given a pointer (see above)
   //  to an associated function myfunc, one can retrieve the function/fit
   //  parameters with calls such as:
   //    Double_t chi2 = myfunc->GetChisquare();
   //    Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter
   //    Double_t err0 = myfunc->GetParError(0);  //error on first parameter
   //
   //  Fit Statistics
   //  ==============
   //  You can change the statistics box to display the fit parameters with
   //  the TStyle::SetOptFit(mode) method. This mode has four digits.
   //  mode = pcev  (default = 0111)
   //    v = 1;  print name/values of parameters
   //    e = 1;  print errors (if e=1, v must be 1)
   //    c = 1;  print Chisquare/Number of degress of freedom
   //    p = 1;  print Probability
   //
   //  For example: gStyle->SetOptFit(1011);
   //  prints the fit probability, parameter names/values, and errors.
   //  You can change the position of the statistics box with these lines
   //  (where g is a pointer to the TGraph):
   //
   //  Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject("stats")
   //  Root > st->SetX1NDC(newx1); //new x start position
   //  Root > st->SetX2NDC(newx2); //new x end position
   
   Int_t fitResult = 0;
   Double_t xmin, xmax, ymin, ymax;
   Int_t i, npar,nvpar,nparx;
   Double_t par, we, al, bl;
   Double_t eplus,eminus,eparab,globcc,amin,edm,errdef,werr;
   TF2 *fnew2;

   Double_t *arglist = new Double_t[100];

   // Decode string choptin and fill fitOption structure
   Foption_t fitOption;
   fitOption.Quiet   = 0;
   fitOption.Verbose = 0;
   fitOption.Bound   = 0;
   fitOption.Like    = 0;
   fitOption.W1      = 0;
   fitOption.Errors  = 0;
   fitOption.Range   = 0;
   fitOption.Gradient= 0;
   fitOption.Nograph = 0;
   fitOption.Nostore = 0;
   fitOption.Plus    = 0;
   fitOption.User    = 0;

   TString opt = option;
   opt.ToUpper();

   if (opt.Contains("U")) fitOption.User    = 1;
   if (opt.Contains("Q")) fitOption.Quiet   = 1;
   if (opt.Contains("V")){fitOption.Verbose = 1; fitOption.Quiet   = 0;}
   if (opt.Contains("W")) fitOption.W1      = 1;
   if (opt.Contains("E")) fitOption.Errors  = 1;
   if (opt.Contains("R")) fitOption.Range   = 1;
   if (opt.Contains("N")) fitOption.Nostore = 1;
   if (opt.Contains("0")) fitOption.Nograph = 1;
   if (opt.Contains("+")) fitOption.Plus    = 1;
   if (opt.Contains("B")) fitOption.Bound   = 1;

   xmin    = GetXmin();
   xmax    = GetXmax();
   ymin    = GetYmin();
   ymax    = GetYmax();

///xmin    = fX[0];
///xmax    = fX[fNpoints-1];
///ymin    = fY[0];
///ymax    = fY[fNpoints-1];
///Double_t err0 = GetErrorX(0);
///Double_t errn = GetErrorX(fNpoints-1);
///if (err0 > 0) xmin -= 2*err0;
///if (errn > 0) xmax += 2*errn;
///for (i=0;i<fNpoints;i++) {
///   if (fX[i] < xmin) xmin = fX[i];
///   if (fX[i] > xmax) xmax = fX[i];
///   if (fY[i] < ymin) ymin = fY[i];
///   if (fY[i] > ymax) ymax = fY[i];
///}
///if (rxmax > rxmin) {
///   xmin = rxmin;
///   xmax = rxmax;
///}

   // Check if Minuit is initialized and create special functions
   TVirtualFitter *grFitter = TVirtualFitter::Fitter(this);
   grFitter->Clear();


   // Get pointer to the function by searching in the list of functions in ROOT
   grFitter->SetUserFunc(f2);
   grFitter->SetFitOption(fitOption);
   
   if (!f2) { Printf("Function is a null pointer"); return 0; }
   npar = f2->GetNpar();
   if (npar <=0) { Printf("Illegal number of parameters = %d",npar); return 0; }

   // Check that function has same dimension as histogram
   if (f2->GetNdim() != 2) {
      Error("Fit","Function %s is not 1-D",f2->GetName()); 
      return 0;
   }

//*-*- Is a Fit range specified?
///Int_t gxfirst, gxlast;
///if (fitOption.Range) {
///   f2->GetRange(xmin, ymin, xmax, ymax);
///   gxfirst = fNpoints +1;
///   gxlast  = -1;
///   for (i=0;i<fNpoints;i++) {
///      if (fX[i] >= xmin && gxfirst > i) gxfirst = i;
///      if (fX[i] <= xmax  && gxlast < i) gxlast  = i;
///   }
///} else {
///   f2->SetRange(xmin, ymin, xmax, ymax);
///   gxfirst = 0;
///   gxlast  = fNpoints-1;
///}

   // Some initialisations
   if (!fitOption.Verbose) {
      arglist[0] = -1;
      grFitter->ExecuteCommand("SET PRINT", arglist,1);
      arglist[0] = 0;
      grFitter->ExecuteCommand("SET NOW",   arglist,0);
   }

   // Set error criterion for chisquare
   arglist[0] = 1;
   if (!fitOption.User) grFitter->SetFitMethod("Graph2DFitChisquare");
   fitResult = grFitter->ExecuteCommand("SET ERR",arglist,1);
   if (fitResult != 0) {
     // Abnormal termination, MIGRAD might not have converged on a minimum.
     if (!fitOption.Quiet) {
        Warning("Fit","Abnormal termination of minimization.");
     }
     return fitResult;
   }

   // Transfer names and initial values of parameters to Minuit
   Int_t nfixed = 0;
   for (i=0;i<npar;i++) {
      par = f2->GetParameter(i);
      f2->GetParLimits(i,al,bl);
      if (al*bl != 0 && al >= bl) {
         al = bl = 0;
         arglist[nfixed] = i+1;
         nfixed++;
      }
      we  = 0.3*TMath::Abs(par);
      if (we <= TMath::Abs(par)*1e-6) we = 1;
      grFitter->SetParameter(i,f2->GetParName(i),par,we,al,bl);
   }
   if(nfixed > 0)grFitter->ExecuteCommand("FIX",arglist,nfixed); // Otto

   // Reset Print level
   if (fitOption.Verbose) {
      arglist[0] = 0; grFitter->ExecuteCommand("SET PRINT", arglist,1);
   }

   // Compute sum of squares of errors in the bin range
   Bool_t hasErrors = kFALSE;
   Double_t sumw2=0;
///Double_t ex, ey, sumw2=0;
///for (i=gxfirst;i<=gxlast;i++) {
///   ex = GetErrorX(i);
///   ey = GetErrorY(i);
///   if (ex > 0 || ey > 0) hasErrors = kTRUE;
///   sumw2 += ey*ey;
///}
//*-*- Perform minimization
///if (!InheritsFrom("TGraphErrors")) SetBit(kFitInit);
   arglist[0] = TVirtualFitter::GetMaxIterations();
   arglist[1] = sumw2*TVirtualFitter::GetPrecision();
   grFitter->ExecuteCommand("MIGRAD",arglist,2);
   if (fitOption.Errors) {
      grFitter->ExecuteCommand("HESSE",arglist,0);
      grFitter->ExecuteCommand("MINOS",arglist,0);
   }

   grFitter->GetStats(amin,edm,errdef,nvpar,nparx);
   f2->SetChisquare(amin);
   Int_t ndf = f2->GetNumberFitPoints()-npar+nfixed;
   f2->SetNDF(ndf);

   // Get return status
   char parName[50];
   for (i=0;i<npar;i++) {
      grFitter->GetParameter(i,parName, par,we,al,bl);
      if (!fitOption.Errors) werr = we;
      else {
         grFitter->GetErrors(i,eplus,eminus,eparab,globcc);
         if (eplus > 0 && eminus < 0) werr = 0.5*(eplus-eminus);
         else                         werr = we;
      }
      if (!hasErrors && ndf > 1) werr *= TMath::Sqrt(amin/(ndf-1));
      f2->SetParameter(i,par);
      f2->SetParError(i,werr);
   }

   // Print final values of parameters.
   if (!fitOption.Quiet) {
      if (fitOption.Errors) grFitter->PrintResults(4,amin);
      else                  grFitter->PrintResults(3,amin);
   }
   delete [] arglist;

   // Store fitted function in histogram functions list and draw
   if (!fitOption.Nostore) {
      if (!fFunctions) fFunctions = new TList;
      if (!fitOption.Plus) {
         TIter next(fFunctions, kIterBackward);
         TObject *obj;
         while ((obj = next())) {
            if (obj->InheritsFrom(TF1::Class())) delete obj;
         }
      }
      fnew2 = new TF2();
      f2->Copy(*fnew2);
      fFunctions->Add(fnew2);
      fnew2->SetParent(this);
      fnew2->Save(xmin,xmax,0,0,0,0);
      if (fitOption.Nograph) fnew2->SetBit(TF1::kNotDraw);
      fnew2->SetBit(TFormula::kNotGlobal);

      if (TestBit(kCanDelete)) return fitResult;
      if (gPad) gPad->Modified();
   }
   return fitResult;
}


//______________________________________________________________________________
TH2D *TGraph2D::GetHistogram() const
{
   // Returns a pointer to the Delaunay histogram. If fHistogram doesn't exist,
   // books the 2D histogram fHistogram with a margin around the hull.
   // Calls ComputeZ at each bin centre to build up interpolated 2D histogram

   if (fHistogram) return fHistogram;

   Double_t x, y, z, sx, sy;
   Int_t N;
   Double_t xmax  = GetXmax();
   Double_t ymax  = GetYmax();
   Double_t xmin  = GetXmin();
   Double_t ymin  = GetYmin();
   Double_t hxmax = xmax+fMargin*(xmax-xmin);
   Double_t hymax = ymax+fMargin*(ymax-ymin);
   Double_t hxmin = xmin-fMargin*(xmax-xmin);
   Double_t hymin = ymin-fMargin*(ymax-ymin);

   ((TGraph2D*)this)->fHistogram = new TH2D(GetName(),GetTitle(),
                                            fNpx ,hxmin, hxmax,
                                            fNpy, hymin, hymax);

   ((TGraph2D*)this)->fXoffset     = -(xmax+xmin)/2.;
   ((TGraph2D*)this)->fYoffset     = -(ymax+ymin)/2.;
   ((TGraph2D*)this)->fScaleFactor = 2./((xmax-xmin)+(ymax-ymin));

   // Offset fX and fY so they average zero, and scale so the average of the 
   // X and Y ranges is one. The normalized version of fX and fY used 
   // in ComputeZ.
   if (!fXN) {
      ((TGraph2D*)this)->fXNmax = (xmax+fXoffset)*fScaleFactor;
      ((TGraph2D*)this)->fXNmin = (xmin+fXoffset)*fScaleFactor;
      ((TGraph2D*)this)->fYNmax = (ymax+fYoffset)*fScaleFactor;
      ((TGraph2D*)this)->fYNmin = (ymin+fYoffset)*fScaleFactor;
      ((TGraph2D*)this)->fXN    = new Double_t[fNpoints+1];
      ((TGraph2D*)this)->fYN    = new Double_t[fNpoints+1];
      for (N=0; N<fNpoints; N++) {
         fXN[N+1] = (fX[N]+fXoffset)*fScaleFactor;
         fYN[N+1] = (fY[N]+fYoffset)*fScaleFactor;
      }
   }

   ((TGraph2D*)this)->FindHull();

   Double_t dx = (hxmax-hxmin)/fNpx;
   Double_t dy = (hymax-hymin)/fNpy;

   for (Int_t ix=1; ix<=fNpx; ix++) {
      x  = hxmin+(ix-0.5)*dx;
      sx = (x+fXoffset)*fScaleFactor;
      for (Int_t iy=1; iy<=fNpy; iy++) {
         y  = hymin+(iy-0.5)*dy;
         sy = (y+fYoffset)*fScaleFactor;
         z  = ((TGraph2D*)this)->ComputeZ(sx, sy);
         fHistogram->Fill(x, y, z);
      }
   }

   if (fMinimum != -1111) fHistogram->SetMinimum(fMinimum);
   if (fMaximum != -1111) fHistogram->SetMaximum(fMaximum);

   fHistogram->SetBit(TH1::kNoStats);

   return fHistogram;
}


//______________________________________________________________________________
Double_t TGraph2D::GetXmax() const
{
   // Returns the X maximum

   Double_t v = fX[0];
   for (Int_t i=1; i<fNpoints; i++) if (fX[i]>v) v=fX[i];
   return v;
}


//______________________________________________________________________________
Double_t TGraph2D::GetXmin() const
{
   // Returns the X minimum

   Double_t v = fX[0];
   for (Int_t i=1; i<fNpoints; i++) if (fX[i]<v) v=fX[i];
   return v;
}


//______________________________________________________________________________
Double_t TGraph2D::GetYmax() const
{
   // Returns the Y maximum

   Double_t v = fY[0];
   for (Int_t i=1; i<fNpoints; i++) if (fY[i]>v) v=fY[i];
   return v;
}


//______________________________________________________________________________
Double_t TGraph2D::GetYmin() const
{
   // Returns the Y minimum

   Double_t v = fY[0];
   for (Int_t i=1; i<fNpoints; i++) if (fY[i]<v) v=fY[i];
   return v;
}


//______________________________________________________________________________
Double_t TGraph2D::GetZmax() const
{
   // Returns the Z maximum

   Double_t v = fZ[0];
   for (Int_t i=1; i<fNpoints; i++) if (fZ[i]>v) v=fZ[i];
   return v;
}


//______________________________________________________________________________
Double_t TGraph2D::GetZmin() const
{
   // Returns the Z minimum

   Double_t v = fZ[0];
   for (Int_t i=1; i<fNpoints; i++) if (fZ[i]<v) v=fZ[i];
   return v;
}


//______________________________________________________________________________
void TGraph2D::Paint(Option_t *option)
{
   // Paints this 2D graph with its current attributes

   TString opt = option;
   opt.ToLower();

   if (opt.Contains("tri") || opt.Contains("p")) {
      PaintTriangles(option);
   } else {
      GetHistogram();
      fHistogram->SetLineColor(GetLineColor());
      fHistogram->SetLineStyle(GetLineStyle());
      fHistogram->SetLineWidth(GetLineWidth());
      fHistogram->SetFillColor(GetFillColor());
      fHistogram->SetFillStyle(GetFillStyle());
      fHistogram->SetMarkerColor(GetMarkerColor());
      fHistogram->SetMarkerStyle(GetMarkerStyle());
      fHistogram->SetMarkerSize(GetMarkerSize());
      fHistogram->Paint(option);
   }
}


//______________________________________________________________________________
void TGraph2D::PaintTriangles(Option_t *option)
{
   // Paints the 2D graph triangles

   Double_t x[4], y[4], temp1[3],temp2[3];
   Int_t N,T0,T[3];

   GetHistogram();

   TString opt = option;
   Bool_t triangles = opt.Contains("tri"); 
   Bool_t markers   = opt.Contains("p");
   Bool_t wire      = opt.Contains("w");
   Bool_t same      = opt.Contains("s");
   Bool_t backbox   = opt.Contains("bb");
   Bool_t frontbox  = opt.Contains("fb");
   Bool_t axis      = opt.Contains("a");
   Bool_t logx      = gPad->GetLogx();
   Bool_t logy      = gPad->GetLogy();
   Bool_t logz      = gPad->GetLogz();

   if (!same) {
      if (!backbox) {
         fHistogram->Paint("BB");
      } else {
         fHistogram->Paint("bb");
      }
      if (!axis) fHistogram->Paint("abb");
   }

   TView *view = gPad->GetView();
   if (!view) {
      Error("PaintTriangles", "no TView in current pad");
      return;
   }

   // Compute minimums and maximums
   TAxis *xaxis = fHistogram->GetXaxis();
   Int_t first = xaxis->GetFirst();
   Double_t xmin = xaxis->GetBinLowEdge(first);
   if (logx && xmin <= 0) xmin = xaxis->GetBinUpEdge(xaxis->FindFixBin(0.01*xaxis->GetBinWidth(first)));
   TAxis *yaxis = fHistogram->GetYaxis();
   first = yaxis->GetFirst();
   Double_t ymin = yaxis->GetBinLowEdge(first);
   if (logy && ymin <= 0) ymin = yaxis->GetBinUpEdge(yaxis->FindFixBin(0.01*yaxis->GetBinWidth(first)));
   Double_t zmax = fHistogram->GetMaximum();
   Double_t zmin = fHistogram->GetMinimum();
   if (logz && zmin <= 0) zmin = TMath::Min((Double_t)1, (Double_t)0.001*fHistogram->GetMaximum());


   // For each triangle, compute the distance between the triangle centre
   // and the back planes. Then these distances are sorted in order to draw
   // the triangles from back to front. 
   if (triangles) {
      FindAllTriangles();
      Double_t cp = TMath::Cos(view->GetLongitude()*TMath::Pi()/180.);
      Double_t sp = TMath::Sin(view->GetLongitude()*TMath::Pi()/180.);
      if (fOrder) {delete [] fOrder; fOrder = 0;}
      if (fDist)  {delete [] fDist; fDist = 0;}
      fOrder = new Int_t[fNdt];
      fDist  = new Double_t[fNdt];
      Double_t xd,yd;
      Int_t i1,i2,i3;
      Bool_t o = kFALSE;
      for (N=0; N<fNdt; N++) {
         i1 = fTried[N]/1000000;
         i2 = (fTried[N]%1000000)/1000;
         i3 = fTried[N]%1000;
         xd = (fXN[i1]+fXN[i2]+fXN[i3])/3;
         yd = (fYN[i1]+fYN[i2]+fYN[i3])/3;
         if ((cp >= 0) && (sp >= 0.)) {
            fDist[N] = -(fXNmax-xd+fYNmax-yd);
         } else if ((cp <= 0) && (sp >= 0.)) {
            fDist[N] = -(fXNmax-xd+yd-fYNmin);
            o = kTRUE;
         } else if ((cp <= 0) && (sp <= 0.)) {
            fDist[N] = -(xd-fXNmin+yd-fYNmin);
         } else {
            fDist[N] = -(xd-fXNmin+fYNmax-yd);
            o = kTRUE;
         }
      }
      TMath::Sort(fNdt, fDist, fOrder, o);
   }
   
   // Draw markers only
   if (markers && !triangles) {
      Double_t *xm = new Double_t[fNpoints]; 
      Double_t *ym = new Double_t[fNpoints];
      for (N=0; N<fNpoints; N++) {
         temp1[0] = fX[N];
         temp1[1] = fY[N];
         temp1[2] = fZ[N];
         temp1[0] = TMath::Max(temp1[0],xmin);
         temp1[1] = TMath::Max(temp1[1],ymin);
         temp1[2] = TMath::Max(temp1[2],zmin);
         temp1[2] = TMath::Min(temp1[2],zmax);
         if (logx) temp1[0] = TMath::Log10(temp1[0]);
         if (logy) temp1[1] = TMath::Log10(temp1[1]);
         if (logz) temp1[2] = TMath::Log10(temp1[2]);
         view->WCtoNDC(temp1, &temp2[0]);
         xm[N] = temp2[0];
         ym[N] = temp2[1];
      }
      SetMarkerStyle(20);
      SetMarkerSize(0.4);
      SetMarkerColor(0);
      TAttMarker::Modify();
      gPad->PaintPolyMarker(fNpoints,xm,ym);
      SetMarkerStyle(24);
      SetMarkerColor(1);
      TAttMarker::Modify();
      gPad->PaintPolyMarker(fNpoints,xm,ym);
      delete [] xm;
      delete [] ym;

   // Draw the triangles and markers if requested
   } else if (triangles) {
      SetFillColor(GetFillColor());
      SetFillStyle(GetFillStyle());
      TAttFill::Modify();
      SetLineColor(GetLineColor());
      TAttLine::Modify();
      for (N=0; N<fNdt; N++) {
         T0   = fTried[fOrder[N]];
         T[0] = T0/1000000;
         T[1] = (T0%1000000)/1000;
         T[2] = T0%1000;
         for (Int_t t=0; t<3; t++) {
            temp1[0] = fX[T[t]-1];
            temp1[1] = fY[T[t]-1];
            temp1[2] = fZ[T[t]-1];
            temp1[0] = TMath::Max(temp1[0],xmin);
            temp1[1] = TMath::Max(temp1[1],ymin);
            temp1[2] = TMath::Max(temp1[2],zmin);
            temp1[2] = TMath::Min(temp1[2],zmax);
            if (logx) temp1[0] = TMath::Log10(temp1[0]);
            if (logy) temp1[1] = TMath::Log10(temp1[1]);
            if (logz) temp1[2] = TMath::Log10(temp1[2]);
            view->WCtoNDC(temp1, &temp2[0]);
            x[t] = temp2[0];
            y[t] = temp2[1];
         }
         x[3] = x[0];
         y[3] = y[0];
         if (!wire) gPad->PaintFillArea(3,x,y);
         gPad->PaintPolyLine(4,x,y);
         if (markers) {
            SetMarkerStyle(20);
            SetMarkerSize(0.4);
            SetMarkerColor(0);
            TAttMarker::Modify();
            gPad->PaintPolyMarker(3,x,y);
            SetMarkerStyle(24);
            SetMarkerColor(1);
            TAttMarker::Modify();
            gPad->PaintPolyMarker(3,x,y);
         }
      }
      delete [] fOrder; fOrder = 0;
      delete [] fDist; fDist = 0;
   }

   if (!same && !frontbox) fHistogram->Paint("fb");
}

//______________________________________________________________________________
TH1 *TGraph2D::Project(Option_t *option) const
{
   // Projects a 2-d graph into 1 or 2-d histograms depending on the
   // option parameter
   // option may contain a combination of the characters x,y,z
   // option = "x" return the x projection into a TH1D histogram
   // option = "y" return the y projection into a TH1D histogram
   // option = "xy" return the x versus y projection into a TH2D histogram
   // option = "yx" return the y versus x projection into a TH2D histogram

   TString opt = option; opt.ToLower();

   Int_t pcase = 0;
   if (opt.Contains("x"))  pcase = 1;
   if (opt.Contains("y"))  pcase = 2;
   if (opt.Contains("xy")) pcase = 3;
   if (opt.Contains("yx")) pcase = 4;
    
   // Create the projection histogram
   TH1D *h1 = 0;
   TH2D *h2 = 0; 
   Int_t nch = strlen(GetName()) +opt.Length() +2;
   char *name = new char[nch];
   sprintf(name,"%s_%s",GetName(),option);
   nch = strlen(GetTitle()) +opt.Length() +2;
   char *title = new char[nch];
   sprintf(title,"%s_%s",GetTitle(),option);

   Double_t hxmin = GetXmin();
   Double_t hxmax = GetXmax();
   Double_t hymin = GetYmin();
   Double_t hymax = GetYmax();

   switch (pcase) {
      case 1:
         // "x"
         h1 = new TH1D(name,title,fNpx,hxmin,hxmax);
         break;
      case 2:
         // "y"
         h1 = new TH1D(name,title,fNpy,hymin,hymax);
         break;
      case 3:
         // "xy"
         h2 = new TH2D(name,title,fNpx,hxmin,hxmax,fNpy,hymin,hymax);
         break;
      case 4:
         // "yx"
         h2 = new TH2D(name,title,fNpy,hymin,hymax,fNpx,hxmin,hxmax);
         break;
   }

   delete [] name;
   delete [] title;
   TH1 *h = h1;
   if (h2) h = h2;
   if (h == 0) return 0;

   // Fill the projected histogram
   Double_t entries = 0;
   for (Int_t N=0; N<fNpoints; N++) {
      switch (pcase) {
         case 1:
            // "x"
            h1->Fill(fX[N], fZ[N]);
            break;
         case 2:
            // "y"
            h1->Fill(fY[N], fZ[N]);
            break;
         case 3:
            // "xy"
            h2->Fill(fX[N], fY[N], fZ[N]);
            break;
         case 4:
            // "yx"
            h2->Fill(fY[N], fX[N], fZ[N]);
            break;
      }
      entries += fZ[N];
   }
   h->SetEntries(entries);
   return h;
}


//______________________________________________________________________________
Int_t TGraph2D::RemovePoint(Int_t ipoint)
{
   // Deletes point number ipoint

   if (ipoint < 0) return -1;
   if (ipoint >= fNpoints) return -1;

   fNpoints--;
   Double_t *newX = new Double_t[fNpoints];
   Double_t *newY = new Double_t[fNpoints];
   Double_t *newZ = new Double_t[fNpoints];
   Int_t j = -1;
   for (Int_t i=0;i<fNpoints+1;i++) {
      if (i == ipoint) continue;
      j++;
      newX[j] = fX[i];
      newY[j] = fY[i];
      newZ[j] = fZ[i];
   }
   delete [] fX;
   delete [] fY;
   delete [] fZ;
   fX = newX;
   fY = newY;
   fZ = newZ;
   Update(1);
   return ipoint;
}


//______________________________________________________________________________
void TGraph2D::SavePrimitive(ofstream &out, Option_t *option)
{
   // Saves primitive as a C++ statement(s) on output stream out

   char quote = '"';
   out<<"   "<<endl;
   if (gROOT->ClassSaved(TGraph2D::Class())) {
      out<<"   ";
   } else {
      out<<"   TGraph2D *";
   }

   out<<"graph = new TGraph2D("<<fNpoints<<");"<<endl;
   out<<"   graph->SetName("<<quote<<GetName()<<quote<<");"<<endl;
   out<<"   graph->SetTitle("<<quote<<GetTitle()<<quote<<");"<<endl;
   
   SaveFillAttributes(out,"graph",0,1001);
   SaveLineAttributes(out,"graph",1,1,1);
   SaveMarkerAttributes(out,"graph",1,1,1);

   for (Int_t i=0;i<fNpoints;i++) {
      out<<"   graph->SetPoint("<<i<<","<<fX[i]<<","<<fY[i]<<","<<fZ[i]<<");"<<endl;
   }

   // save list of functions
   TIter next(fFunctions);
   TObject *obj;
   while ((obj=next())) {
      obj->SavePrimitive(out,"nodraw");
      out<<"   graph->GetListOfFunctions()->Add("<<obj->GetName()<<");"<<endl;
      if (obj->InheritsFrom("TPaveStats")) {
         out<<"   ptstats->SetParent(graph->GetListOfFunctions());"<<endl;
      }
   }

   out<<"   graph->Draw("<<quote<<option<<quote<<");"<<endl;
}


//______________________________________________________________________________
void TGraph2D::SetMargin(Double_t m)
{
   // Sets the extra space (in %) around interpolated area for the 2D histogram

   if (m<0 || m>1) {
      Warning("SetMargin","The margin must be >= 0 && <= 1, fMargin set to 0.1");
      fMargin = 0.1;
   } else {
      fMargin = m;
   }
   Update();
}


//______________________________________________________________________________
void TGraph2D::SetMaximum(Double_t maximum)
{  
   fMaximum = maximum;   
   GetHistogram()->SetMaximum(maximum);
}

   
//______________________________________________________________________________
void TGraph2D::SetMinimum(Double_t minimum)
{
   fMinimum = minimum;
   GetHistogram()->SetMinimum(minimum);
}


//______________________________________________________________________________
void TGraph2D::SetNpx(Int_t npx)
{
   // Sets the number of bins along X used to draw the function

   if (npx < 4) {
      Warning("SetNpx","Number of points must be >4 && < 500, fNpx set to 4");
      fNpx = 4;
   } else if(npx > 500) {
      Warning("SetNpx","Number of points must be >4 && < 500, fNpx set to 500");
      fNpx = 100000;
   } else {
      fNpx = npx;
   }
   Update();
}


//______________________________________________________________________________
void TGraph2D::SetNpy(Int_t npy)
{
   // Sets the number of bins along Y used to draw the function

   if (npy < 4) {
      Warning("SetNpy","Number of points must be >4 && < 500, fNpy set to 4");
      fNpy = 4;
   } else if(npy > 500) {
      Warning("SetNpy","Number of points must be >4 && < 500, fNpy set to 500");
      fNpy = 100000;
   } else {
      fNpy = npy;
   }
   Update();
}


//______________________________________________________________________________
void TGraph2D::SetMarginBinsContent(Double_t z)
{
   // Sets the histogram bin height for points lying outside the convex hull ie:
   // the bins in the margin.

   fZout = z;
   Update();
}

//______________________________________________________________________________
void TGraph2D::SetPoint(Int_t n, Double_t x, Double_t y, Double_t z)
{  
   // Sets point number n.
   // If n is greater than the current size, the arrays are automatically
   // extended.
       
   if (n < 0) return;

   if (!fX || !fY || !fZ || n >= fSize) {
   // re-allocate the object 
      Int_t newN = TMath::Max(2*fSize,n+1);
      Double_t *savex = new Double_t [newN];
      Double_t *savey = new Double_t [newN];
      Double_t *savez = new Double_t [newN];
      if (fX && fSize) {
         memcpy(savex,fX,fSize*sizeof(Double_t));
         memset(&savex[fSize],0,(newN-fSize)*sizeof(Double_t));
         delete [] fX;
      }
      if (fY && fSize) {
         memcpy(savey,fY,fSize*sizeof(Double_t));
         memset(&savey[fSize],0,(newN-fSize)*sizeof(Double_t));
         delete [] fY;
      }
      if (fZ && fSize) {
         memcpy(savez,fZ,fSize*sizeof(Double_t));
         memset(&savez[fSize],0,(newN-fSize)*sizeof(Double_t));
         delete [] fZ;
      }
      fX    = savex;
      fY    = savey;
      fZ    = savez;
      fSize = newN;
   }
   fX[n]    = x;
   fY[n]    = y;
   fZ[n]    = z;
   fNpoints = TMath::Max(fNpoints,n+1);
}


//______________________________________________________________________________
void TGraph2D::SetTitle(const char* title)
{
   // Sets graph title

   fTitle = title;
   if (fHistogram) fHistogram->SetTitle(title);
}


//______________________________________________________________________________
Int_t TGraph2D::TriEncode(Int_t T1, Int_t T2, Int_t T3) const
{
   // Forms the point numbers into a single number to represent the triangle

   Int_t triencode = 0;
   Int_t MinT = T1;
   Int_t MaxT = T1;
   if (T2 > MaxT) MaxT = T2;
   if (T3 > MaxT) MaxT = T3;
   if (T2 < MinT) MinT = T2;
   if (T3 < MinT) MinT = T3;
   
   triencode = 1000000*MaxT+MinT;
   if ((T1!=MaxT) && (T1!=MinT)) {
      triencode = triencode+1000*T1;
   } else if ((T2!=MaxT) && (T2!=MinT)) {
      triencode = triencode+1000*T2;
   } else if ((T3!=MaxT) && (T3!=MinT)) {
      triencode = triencode+1000*T3;
   } else {
      Error("TriEncode", "Should not get to here");
   }
   return triencode;
}


//_______________________________________________________________________
void TGraph2D::Update(Int_t level)
{
   // Called each time fHistogram should be recreated.
   // level = 0 : it is enough to only delete fHistogram
   // level = 1 : the data set has changed, the hull and triangles 
   //             must be recomputed.

   if (fHistogram)  {delete fHistogram; fHistogram = 0;}
   if (level == 0) return;
   if (fHullPoints) {delete [] fHullPoints; fHullPoints = 0;}
   if (fOrder)      {delete [] fOrder; fOrder = 0;}
   if (fDist)       {delete [] fDist; fDist = 0;}
   if (fXN)         {delete [] fXN; fXN = 0;}
   if (fYN)         {delete [] fYN; fYN = 0;}
   fNhull = 0;
   fNdt   = 0;
   fNxt   = 0;
}
