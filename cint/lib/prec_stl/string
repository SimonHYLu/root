// lib/prec_stl/string

#pragma ifndef PREC_STL_STRING
#pragma define PREC_STL_STRING
#pragma link off global PREC_STL_STRING;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;
#if defined(G__HP_aCC) || defined(G__SUNPRO_C)
#pragma mask_newdelete 0x1c;
#else
#pragma mask_newdelete 0x10;
#endif

// string class wrapper , by Masaharu Goto
// Template is on purposely avoided.

#include <stddef.h>
#include <iostream>

//////////////////////////////////////////////////////////////////////////
class string {
 public:
  typedef char value_type;
  typedef char* pointer;
  typedef const char* const_pointer;
  typedef char& reference;
  typedef const char& const_reference;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef int traits_type;

#if defined(G__KCC) 
  typedef typename Allocator::pointer		   iterator;
  typedef const iterator const_iterator;
#elif defined(G__AIXOLD)
  typedef _Ptrit<value_type, difference_type, pointer,
                  reference, pointer, reference> iterator;
  typedef _Ptrit<value_type, difference_type, const_pointer,
                  const_reference, pointer, reference> const_iterator;
#elif (G__GNUC>=3 && G__GNUC_MINOR>=1) 
  class iterator {
   public:
      iterator();
      explicit iterator(const pointer& __i) ;
      // Allow iterator to const_iterator conversion
      template<typename _Iter> inline iterator(const iterator& __i);

      // Forward iterator requirements
      reference operator*() const ;
      pointer operator->() const ;
      iterator& operator++();
      iterator operator++(int) ;
      
      // Bidirectional iterator requirements
      iterator& operator--() ;
      iterator operator--(int) ;
      
      // Random access iterator requirements
      reference operator[](const difference_type& __n) const;
      iterator& operator+=(const difference_type& __n);
      iterator operator+(const difference_type& __n) const;
      iterator& operator-=(const difference_type& __n);
      iterator operator-(const difference_type& __n) const;
      const pointer& base() const ;
  };
  typedef const iterator const_iterator;
#elif (G__GNUC>=3 && G__GNUC_MINOR==0)
  typedef char* iterator;
  typedef const char* const_iterator;
#else
  typedef char* iterator;
  typedef const char* const_iterator;
#endif

  enum { npos=-1 };
  string() ;
  //string(size_t size,capacity cap) ;
  string(const string& str) ;
  string(const string& str,size_t pos,size_t n) ;
  string(const char* s,size_t n) ;
  string(const char* s) ;
  string(char c,size_t rep);
  //string(const vector<char>& vec);
  ~string() ;
  string& operator=(const string& str);
  string& operator=(const char* s);
  string& operator=(char c);
  string& operator+=(const string& rhs);
  string& operator+=(const char* s);
  string& operator+=(char c);
  //vector<char> operator vector<char>(void) const;
  string& append(const string& str);
  string& append(const string& str,size_t pos,size_t n);
  string& append(const char* s,size_t n);
  string& append(const char* s);
  string& append(char c,size_t rep);
  string& assign(const string& str);
  string& assign(const string& str,size_t pos,size_t n);
  string& assign(const char* s,size_t n);
  string& assign(const char* s);
  string& assign(char c,size_t rep);
  string& insert(size_t pos1,const string& str);
  string& insert(size_t pos1,const string& str,size_t pos2,size_t n);
  string& insert(size_t pos,const char* s,size_t n);
  string& insert(size_t pos,const char* s);
  string& insert(size_t pos,char c,size_t rep);
  //string& remove(size_t pos=0,size_t n=npos);
  string& replace(size_t pos1,size_t n1,const string& str);
  string& replace(size_t pos1,size_t n1,const string& str,size_t pos2,size_t n2);
  string& replace(size_t pos,size_t n1,const char* s,size_t n2);
  string& replace(size_t pos,size_t n1,const char* s);
  string& replace(size_t pos,size_t n,char c,size_t rep);
  //char get_at(size_t pos) const;
  //void put_at(size_t pos,char c);
  char operator[](size_t pos) const;
  const char* c_str(void) const;
  const char* data(void) const;
  size_t length(void) const;
  void resize(size_t n,char c);
  void resize(size_t n);
  int size();
  //size_t reserve(void) const;
  void reserve(size_t res_arg);
  size_t copy(char* s,size_t n,size_t pos=0) /* const */;
  size_t find(const string& str,size_t pos=0) const;
  size_t find(const char* s,size_t pos,size_t n) const;
  size_t find(const char* s,size_t pos=0) const;
  size_t find(char c,size_t pos=0) const;
  size_t rfind(const string& str,size_t pos=npos) const;
  size_t rfind(const char* s,size_t pos,size_t n) const;
  size_t rfind(const char* s,size_t pos=npos) const;
  size_t rfind(char c,size_t pos=npos) const;
  size_t find_first_of(const string& str,size_t pos=0) const;
  size_t find_first_of(const char* s,size_t pos,size_t n) const;
  size_t find_first_of(const char* s,size_t pos=0) const;
  size_t find_first_of(char c,size_t pos=0) const;
  size_t find_last_of(const string& str,size_t pos=npos) const;
  size_t find_last_of(const char* s,size_t pos,size_t n) const;
  size_t find_last_of(const char* s,size_t pos=npos) const;
  size_t find_last_of(char c,size_t pos=npos) const;
  size_t find_first_not_of(const string& str,size_t pos=0) const;
  size_t find_first_not_of(const char* s,size_t pos,size_t n) const;
  size_t find_first_not_of(const char* s,size_t pos=0) const;
  size_t find_first_not_of(char c,size_t pos=0) const;
  size_t find_last_not_of(const string& str,size_t pos=npos) const;
  size_t find_last_not_of(const char* s,size_t pos,size_t n) const;
  size_t find_last_not_of(const char* s,size_t pos=npos) const;
  size_t find_last_not_of(char c,size_t pos=npos) const;
  string substr(size_t pos=0,size_t n=npos) const;
  int compare(const string& str) const;
  //int compare(size_type pos1,size_type n1,const string& str,size_type n2) const;
  int compare(const char* s) const ;
  //int compare(size_type pos1,size_type n1,const char* s,size_type n2=npos)const;
  //operator char*() ;

#ifdef G__TMPLTIOS
  iterator begin();
  const_iterator begin() const;
  iterator end();
  const_iterator end() const;
  size_type capacity() const;
  void clear();
  bool empty() const;
  size_t max_size() const;
#endif
};

bool operator==(const string& a,const string& b) ;
bool operator!=(const string& a,const string& b) ;
bool operator<(const string& a,const string& b) ;
bool operator>(const string& a,const string& b) ;
bool operator<=(const string& a,const string& b) ;
bool operator>=(const string& a,const string& b) ;
string operator+(const string& a,const string& b) ;

typedef string cstring;

#pragma endif 

